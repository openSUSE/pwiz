#! @PW_PATH_BASH@

unalias -a
shopt -s expand_aliases
# FIXME: Set it on for debugging purposes. Otherwise strange globbing problems can occur in real life.
shopt -s nullglob

@genopts

@code_style line_up function_keyword casetab

@options_only

@program pwiz

@version @PW_VERSION@

@year 2004

@author Stanislav Brabec

@bugsto Stanislav Brabec <sbrabec@suse.cz>

@free_copy

@usage [OPTION]...

@short
Packaging Wizard provides a framework for simplification of packaging process.
If you do not want anything special, you can run pwiz without arguments.

@defaults PWIZ_OPTIONS
You can change default behavior by changing many environment variables
(see documentation for PWIZ and modules for more).

@switch PROMPT -p --prompt
Debug shell prompt before and after each stage.

@switch LIST_MODULES --list-modules
List all modules and exit.

@cntswitch VERBOSE -v --verbose
Increase level of verbosity.

@option DEBUG -d --debug=TYPE
Comma separated list of specific debugging messages.
Use --debug=list for all available types.
Use --debug=all for all available debuggings.

@option THRESHOLD -t --threshold=PERCENT 70
Set credit threshold in percents of knownledge
skill (default 70).
Has no effect with -f, -a and -c.
increase: ask more; decrease: ask less

@option CREDIT -c --credit=CREDIT
Set credit threshold. If credible enough answer
exists, don't ask. Default is user's knownledge
skill. Answer importance is ignored.
increase: ask more; decrease: ask less

@switch FAST -f --fast
Run in fast mode. Equivalent of --credit=0.
means: ask nearly nothing

@switch ASK_ALL -a --ask-all
Ask for all questions. Equivalent of --credit=111.
means: ask nearly all

@option GUESSLEVEL -g --guess=PERCENT
Set guess level for selected answers. Force guess
level for user answers instead of asking user.
means: for selected answer don't prompt for: "How sure are you"

@option DEFGUESSLEVEL -G --defguess=PERCENT
Set guess level for default answers. Force guess
level for default answers (i. e. when user does not
change anything) instead of asking user.
means: for default answer don't prompt for: "How sure are you"

@options_only

@end
# FIXME: Implement project.


#@@@ General functions

#@@ Debugging

#@ eecho string
# string: string to be echoed
#
# Alias for echo to stderr.
alias eecho='echo >&2'

if $OPTARG_FAST ; then
    OPTARG_CREDIT=true
    OPTVAL_CREDIT=0
fi

if $OPTARG_ASK_ALL ; then
    OPTARG_CREDIT=true
    OPTVAL_CREDIT=111
fi

#@ vecho string
# string: string to be echoed
#
# Alias for verbose echo. Echo only in verbose mode.
if test $OPTCNT_VERBOSE -ge 1 ; then
    alias vecho='echo >&2'
else
    alias vecho=:
fi

#@ vvecho string
# string: string to be echoed
#
# Alias for more verbose echo. Echo only in more verbose mode.
if test $OPTCNT_VERBOSE -ge 2 ; then
    alias vvecho='echo >&2'
else
    alias vvecho=:
fi

#@ vvvecho string
# string: string to be echoed
#
# Alias for very verbose echo. Echo only in very verbose mode.
if test $OPTCNT_VERBOSE -ge 3 ; then
    alias vvvecho='echo >&2'
else
    alias vvvecho=:
fi

#@ pwiz_debug_feature name desc longdesc
# name: Feature name.
# desc: short description of feature
# longdesc: long description of feature
#
# Define debug features (class of debug messages for --enable-debug).
function pwiz_debug_feature {
    pwiz_array_add pwiz_debug_features "$1"
    eval "pwiz_debug_desc_$1="'"$2"'
    eval "pwiz_debug_longdesc_$1="'"$3"'
}
declare -a pwiz_debug_features


# FIXME
trap "echo \"PWIZ must be error-less\" ; exit 1" ERR

# FIXME: declare most functions readonly (declare -f -r or -F -r, readonly -f)
# FIXME: declare and check integers, where appropriate

# These will be variables in future, not constants.
# FIXME: All those should be queried:
#pwiz_project_project=gnome-panel
#pwiz_project_version_policy=even_subversion_is_stable
pwiz_project_subproject=-
#pwiz_project_version=2.4.0
pwiz_project_vendor=SuSE-Linux-9.1
pwiz_project_build=0

# Debug prompt.
function pwiz_prompt {
    local REPLY
    mkdir -p ~/.pwiz
    local HISTFILE=~/.pwiz/history
    echo
    vecho "Shell prompt. Empty line for exit. Mult-line strings are not allowed."
# FIXME: Maybe global and trap
    history -r
# FIXME: Completion
    while read -e -r -p "$1$PWIZ_PHASE_CURRENT[$PWIZ_STAGE_CURRENT]
$pwiz_step_stage_code
pwiz@$PWD> " ; do
	if test -z "$REPLY" ; then
	    break
	fi
	eval "$REPLY"
	let HISTCMD++
	history -s "$REPLY"
# FIXME: Maybe global and trap
	history -a
    done
    echo
}

#@@ Fast redirection

##@ To simplify coding and make code faster, do a redirection of
#standard streams instead of redirection for particular commands. When
#using these functions, channels 5-7 are reserved for saving original
#redirection.

#@ pwiz_redirect_stdin file
# file: File from which redirect.
#
# Redirect standard input from file. Close by @pwiz_redirect_stdin_close.
function pwiz_redirect_stdin {
    exec 5<&0
    exec <"$1"
}
#@ pwiz_redirect_stdout file
# file: File to which redirect.
#
# Redirect standard output to file. Close by @pwiz_redirect_stdout_close.
function pwiz_redirect_stdout {
    exec 6>&1
    exec >"$1"
}
#@ pwiz_redirect_stderr file
# file: File to which redirect stderr. Close by @pwiz_redirect_stderr_close.
#
# Redirect error output to file.
function pwiz_redirect_stderr {
    exec 7>&2
    exec 2>"$1"
}
#@ pwiz_redirect_stdout_append file
# file: File to which redirect.
#
# Appending redirect standard output to file with. Close by @pwiz_redirect_stdout_close.
function pwiz_redirect_stdout_append {
    exec 6>&1
    exec >>"$1"
}
#@ pwiz_redirect_stderr_append file
# file: File to which redirect stderr.
#
# Appending redirect error output to file with. Close by @pwiz_redirect_stderr_close.
function pwiz_redirect_stderr_append {
    exec 7>&2
    exec 2>>"$1"
}
#@ pwiz_redirect_stdin_close
#
# Revert redirection created by by @pwiz_redirect_stdin and close file.
function pwiz_redirect_stdin_close {
    exec <&-
    exec <&5-
}
#@ pwiz_redirect_stdout_close
#
# Revert redirection created by by @pwiz_redirect_stdout and close file.
function pwiz_redirect_stdout_close {
    exec >&-
    exec >&6-
}
#@ pwiz_redirect_stdout_suspend
#
# Revert redirection created by by @pwiz_redirect_stdout, but don't close file.
function pwiz_redirect_stdout_suspend {
    exec 8>&1
    exec >&6
}
#@ pwiz_redirect_stdout_restore
#
# Restore redirection created by by @pwiz_redirect_stdout and suspended by @pwiz_redirect_stdout_suspend.
function pwiz_redirect_stdout_restore {
    exec >&8-
}
#@ pwiz_redirect_stderr_close
#
# Revert redirection created by by @pwiz_redirect_stderr and close file.
function pwiz_redirect_stderr_close {
    exec 2>&-
    exec 2>&7-
}

#@@ General helpers

#@ pwiz_set_rc return_code
# returns: return_code
#
# Helper, which only sets return code.
function pwiz_set_rc {
    return $1
}

# FIXME: TODO

# Check, whether $1 is integer.
function pwiz_check_int {
    :
}

# Check, whether $1 is natural.
function pwiz_check_natural {
    :
}

# Check, whether $1 is in p range (0-100).
function pwiz_check_p {
    :
}

#@ pwiz_canonize filename
# filename: Name of file in arbitrary form.
# returns $pwiz_result: Canonical form of file name.
#
# Converts file names to canonical form, i. e. no "//", "/../", "/./".
# NOTE: Does not canonize relative paths.
# NOTE: Function is relatively slow. Use C alternative for large
#amount of file names.
function pwiz_canonize {
    local old_name
    pwiz_result="$1"
# // -> /
    old_name=
    while test "$old_name" != "$pwiz_result" ; do
	old_name="$pwiz_result"
	pwiz_result="${pwiz_result//\/\///}"
    done
# /./ -> /
    old_name=
    while test "$old_name" != "$pwiz_result" ; do
	old_name="$pwiz_result"
	pwiz_result="${pwiz_result//\/.\///}"
    done
# /path/../ -> /
    shopt -s extglob
    old_name=
    while test "$old_name" != "$pwiz_result" ; do
	old_name="$pwiz_result"
	pwiz_result="${pwiz_result//\/*([^\/])\/../}"
    done
    shopt -u extglob
}

#@@ File searching

#@ pwiz_find path [ path_prefix ] [ callback_argument_2 ]
# path: Directory, where tu start searching.
# path_prefix: Path prepended to all searched directories, but not to
#output values. Must have trailing slash, if used.
# callback_argument_2: Arbitrary argument to callback function.
# uses: $pwiz_callback path callback_argument_2: callback function.
#Default is echo.
#
# A Bash alternative to simple recursive find for all files and links.
# WARNING: If you want really all files, you must turn on dot globbing
#(shopt -s dotglob).
function pwiz_find {
    local item
    if test -d "$2$1" ; then
	for item in "$2$1/"* ; do
	    pwiz_find "${item#$2}" "$2" "$3"
	done
    else
	$pwiz_callback "${1#$2}" "$3"
    fi
}
pwiz_callback=echo

#@ pwiz_find path [ path_prefix ] [ callback_argument_3 ]
# path: Directory, where tu start searching.
# path_prefix: Path prepended to all searched directories, but not to
#output values. Must have trailing slash, if used.
# callback_argument_3: Arbitrary argument to callback function.
# uses: $pwiz_callback path type callback_argument_3: callback
#function. Default is echo, type is either 'file' or 'dir'.
#
# A Bash alternative to simple recursive find for all dirs, files and
#links.
# WARNING: If you want really all files, you must turn on dot globbing
#(shopt -s dotglob).
function pwiz_find_d {
    local item
    if test -d "$2$1" ; then
	$pwiz_callback "${1#$2}" dir "$3"
	for item in "$2$1/"* ; do
	    pwiz_find_d "${item#$2}" "$2" "$3"
	done
    else
	$pwiz_callback "${1#$2}" file "$3"
    fi
}


#@@@ Project directories

#@ pwiz_projectdirs_init
#
# initialize work directories for project.
# Call it every time you change $pwiz_project_* variables
#@@ Work directories for project.
##@ If not stated anything else, separate directory is created for
#each project. Can be redefined by callback from packaging engine (see
#lower).
function pwiz_projectdirs_init {
    local dir callback
    if test "$pwiz_project_project" = "" ; then
	dir=
    else
	dir="/$pwiz_project_project"
    fi
#@ $PWIZ_CACHEDIR
# Temporary directory for PWIZ modules, which is not cleaned after termination.
#It can be cleaned by user. Mostly for storing downloaded files.
# WARNING: $PWIZ_CACHEDIR is common for all projects!
# WARNING: Do not access here from pwiz_run
# NOTE: Use module name as prefix for all file names here.
    PWIZ_CACHEDIR=~/pwiz/tmpcache
#@ $PWIZ_TMPDIR
# Temporary directory for PWIZ modules.
# WARNING: Do not access here from @pwiz_run.
# NOTE: To prevent name clashes, use module name as prefix for all file names here.
    PWIZ_TMPDIR=~/pwiz/tmp$dir
#@ $PWIZ_SOURCESDIR
# Temporary directory for PWIZ source codes.
# WARNING: Do not write here from @pwiz_run.
    PWIZ_SOURCESDIR=~/pwiz/src$dir
#@ $PWIZ_SRCDIR
# Temporary directory for unpacked sources.
# WARNING: Do not use this before SOURCE stage.
# WARNING: In separate build dir mode do not write here after unpack stage.
# WARNING: Do not write here from outside @pwiz_run.
    PWIZ_SRCDIR=~/pwiz/unpack$dir
#@ $PWIZ_BUILDDIR
# Temporary directory for PWIZ build.
# WARNING: Do not use this before PREPARE stage.
# WARNING: Do not write here from outside @pwiz_run.
    PWIZ_BUILDDIR=~/pwiz/build$dir
#@ $PWIZ_INSTALLROOT
# Temporary directory for PWIZ installation root.
# WARNING: Do not use this before INSTALL stage.
# WARNING: Do not write here before INSTALL stage.
# WARNING: Do not write here from outside @pwiz_run.
    PWIZ_INSTALLROOT=~/pwiz/install$dir
#@ $PWIZ_RESULTDIR
# Directory for PWIZ results.
    PWIZ_RESULTDIR=~/pwiz/results$dir
#@ pwiz_projectdirs_init_callback path
# path: path to be appended to directory itself (project subdirecttory)
#
# Initialize work directories for project - array of callback functions.
# Callback can redefine following variables: $PWIZ_SOURCESDIR,
#$PWIZ_SRCDIR, $PWIZ_BUILDDIR, $PWIZ_INSTALLROOT.
# Use @pwiz_array_add to add item to this array.
    for callback in ${pwiz_projectdirs_init_callback[@]} ; do
	$callback "$dir"
    done
    mkdir -p $PWIZ_CACHEDIR
    rm -rf $PWIZ_TMPDIR/*
    mkdir -p $PWIZ_TMPDIR
    rm -rf $PWIZ_SOURCESDIR/*
    if test "$pwiz_project_project" != "" ; then
	mkdir -p $PWIZ_SOURCESDIR
	rm -rf $PWIZ_SRCDIR/*
	mkdir -p $PWIZ_SRCDIR
	rm -rf $PWIZ_BUILDDIR/*
	mkdir -p $PWIZ_BUILDDIR
	rm -rf $PWIZ_INSTALLROOT/*
	mkdir -p $PWIZ_INSTALLROOT
	mkdir -p $PWIZ_RESULTDIR
    fi
}

#@ pwiz_array_add array_name item
# item: value to be added to the array
#
# Add an item as last element of non-sparse array.
# This is only simplification of array[@${#array[@@]}]=item
# NOTE: array_name is without leading '@$' sign.
function pwiz_array_add {
    eval $1'[${#'$1'[@]}]="$2"'
}


#@@@ Run wrappers for protected commands
# Main purposes of run wrappers are:
# - Create environment identical to packaging program and allow to
#execute instructions in steps.
# - Track changed or accessed files, eventually protect system from
#unwanted changes.
# You can use more wrappers in a chain - for example one wrapper
#traces accesses to files in system, another sets special environment
#variables etc.

#@@ Order of pwiz_run execution
# @pwiz_run: Command called by user to start protected command.
# @pwiz_run_prepare: One function defined by build environment system
#(rpm).
# @pwiz_run_wrappers: Chain of run wrappers defining environment
#protection (install watchers, sandboxing, run trace).
# @pwiz_run_core: One function defined by build environment system,
#which does execution and sets $pwiz_run_rc.

# FIXME: [ arguments ... ] should be: command save_command full_revert_command safe_revert_commans standard_revert_command fast_revert_command

#@ pwiz_run_wrapper_register function
# function: Function to be registered.
#
# Register wrapper for @pwiz_run. Wrapper uses pwiz_run_wrap for subsequent call.
# Wrapper function skeleton:
#@<
#function mywrapper {
#    do_something_here
##   you can for example delete or modify some arguments there
#    operate_on "@" # returns ${result[@]}
#    pwiz_run_wrap "${result[@]}" # or simply: pwiz_run_wrap "$@"
#    do_the_rest
#}
#pwiz_run_wrapper_register mywrapper
#@>
function pwiz_run_wrapper_register {
    pwiz_run_function=$1
    eval 'function pwiz_run_wrap_'$pwiz_run_wrapper_count' {
    pwiz_run_wrap_function=pwiz_run_wrap_'$((pwiz_run_wrapper_count-1))'
    '$1' "$@"
}'
    pwiz_run_function=pwiz_run_wrap_$pwiz_run_wrapper_count
    let pwiz_run_wrapper_count++
}
pwiz_run_wrapper_count=1
pwiz_run_function=pwiz_run_core

#@ pwiz_run_wrap [ arguments ... ]
#
# Call next registered wrapper. Functions is used inside run wrapper
#function.
function pwiz_run_wrap {
    $pwiz_run_wrap_function "$@"
}

# pwiz_run_wrap_0 [ arguments ... ] (internal)
#
# Lowest wrapper in chain. Calls directly pwiz_run_core.
function pwiz_run_wrap_0 {
    pwiz_run_core "$@"
}
pwiz_run_rc=0

#@ pwiz_run_core [ arguments ... ]
#
# Immediatelly calls its arguments.
# This function can be redefined by packaging engine to to something
#else.
function pwiz_run_core {
    pwiz_set_rc $pwiz_run_rc
    "$@"
    pwiz_run_rc=$?
}

#@ pwiz_run_prepare [ arguments ... ]
#
# Top level wrapper.
# After preparation calls $pwiz_run_function "@$@@"
# Immediatelly calls its arguments.
# This function can be redefined by packaging engine to to something
#else.
# Run prepare function skeleton:
#@<
#function myprepare {
#    do_something
#    $pwiz_run_function "$@"
#}
#@>
function pwiz_run_prepare {
    $pwiz_run_function "$@"
}

#@ pwiz_run [ arguments ... ]
# returns $pwiz_run_rc: Return code of executed stage command.
# returns: Don't use return code. Use $pwiz_run_rc to get return code
#of protected command.
#
# Run command in protected build environment.
# $pwiz_run_rc is restored before next pwiz_run.
# WARNING: Direct calling of pwiz_run without adding it to phase
#engine is not listed in query mode. If you want to have command in
#resulting package, you must not use pwiz_run directly!
# WARNING: Do not alter pwiz_run_rc!
function pwiz_run {
# FIXME: for debugging only:
# FIXME: Adopt other parts of run stuff to 1 arg
    if test "$2" != "" ; then
	pwiz_fatal "2 arguments: pwiz_run $*"
    fi
    vvecho "running: $*"
    pwiz_run_prepare "$@"
}

# FIXME: deprecated: replace by special phase with two stages
# pwiz_run_eval args
# Expand variables, save them and then call pwiz_run
#function pwiz_run_eval {
#    pwiz_warning "deprecated: pwiz_run_eval $*"
#    eval PWIZ_STAGE_EVAL_$PWIZ_PHASE_CURRENT\[$PWIZ_STAGE_CURRENT\]\=\"\$@\"
#    eval pwiz_run "$@"
#}

# FIXME: now probably obsolete as command. Keep only comment:

#@ pwiz_rem string
# string: arbitrary string
#
# Remark function. Action will appear in stage list, but is not executed.
# Primarily intended for exporting comments to final build script.

#function pwiz_rem {
#    :
#}

# FIXME: deprecated.
# pwiz_rem_eval args
# Expand variables, save them and then call pwiz_rem
#function pwiz_rem_eval {
#    pwiz_warning "deprecated: pwiz_rem_eval $*"
#    eval PWIZ_STAGE_EVAL_$PWIZ_PHASE_CURRENT\[$PWIZ_STAGE_CURRENT\]\=\"\$@\"
#    eval pwiz_rem "$@"
#}

# FIXME: deprecated.
# pwiz_debug level message
#function pwiz_debug {
#    echo "pwiz: $2"
#}

# FIXME: nearly unused. Remove?
# pwiz_fatal error
function pwiz_warning {
    eecho "Packaging wizard warning: $pwiz_module_current: $1"
}

#@ pwiz_fatal string rc
# string: string to be echoed
# rc: return code
#
# Abort PWIZ after fatal error.
function pwiz_fatal {
    eecho "Packaging wizard fatal: $pwiz_module_current: $1"
    pwiz_exit 2
}

#@ pwiz_add_exit function
# function: function to be executed on exit
#
# Register function to be executed on PWIZ exit.
function pwiz_add_exit {
    pwiz_array_add PWIZ_EXIT "$1"
}
declare -a PWIZ_EXIT

#@ pwiz_exit rc
# rc: PWIZ return code
#
# Exit PWIZ.
function pwiz_exit {
    local func
    for func in "${PWIZ_EXIT[@]}" ; do
	eval "$func"
    done
    exit "$@"
}


#@@ Tags
# Tags are used to simplify calls of functions with many optional
#arguments. Idea is simple: Instead of positional arguments you are
#using format tag=value or tag[number]=value. To protect second format
#from expansion, functions using tags sets shell option noglob before
#parsing arguments.

#@ pwiz_read_tags
#
# Read tags to variables.
# Tags are values entered as an argument of some functions in form:
#tag='value' other_tag[1]='other value' This alias reads them to
#variables pwiz_tag_tag='value' pwiz_tag_other_tag[1]='other value' It
#uses special Bash tricks to prevent expansion or word splitting of
#tags. To use it, you probably need to prevent expansion at all,
#expecially in nullglob mode (otherwise tag[number] is expanded to
#empty string) use set -o noglob in function alias.
# WARNING: This function uses global variables, not local! Local
#variables in Bash are inherited to all functions called from inside
#functions, where variable is visible, unless you define your own
#instance. There is no chance to reset it back to global ones. If we
#want to recurse without variable inheritance, there is no chance to
#use local variables, so this function uses global ones.
# Example of function with globbing prevention:
#@<
#alias my_function="set -o noglob ; my_function_f"
#function my_function_f {
#    set +o noglob
#    pwiz_read_tags
#    ...
#}
#@>
alias pwiz_read_tags='local pwiz_tag ; for pwiz_tag in "$@" ; do pwiz_tag=${pwiz_tag//\'\''/\'\''\\\'\''\'\''}\'\'' ; pwiz_tag=${pwiz_tag/=/=\'\''} ; eval pwiz_tag_"$pwiz_tag" ; done'

#@ pwiz_read_vtags
# uses $tags: variable with tags
#
# Read tags from $tags to variables.
# Does the same as @pwiz_read_tags, but reads values from $tags
#instead of $@@. User does not need to care about globbing.
# Tags are values entered as an argument of some functions in form:
#tag='value' other_tag[1]='other value' This alias reads them to
#variables pwiz_vtag_tag='value' pwiz_vtag_other_tag[1]='other value'
#It uses special Bash tricks to prevent expansion or word splitting of
#tags.
# WARNING: This function resets noglob shell option.
alias pwiz_read_vtags='set -o noglob ; local pwiz_vtag ; eval '\''for pwiz_vtag in '\''"$tags"'\'' ; do pwiz_vtag=${pwiz_vtag//\'\''\'\'''\''/\'\''\'\'''\''\\\'\''\'\'''\''\'\''\'\'''\''}\'\''\'\'''\'' ; pwiz_vtag=${pwiz_vtag/=/=\'\''\'\'''\''} ; eval pwiz_vtag_"$pwiz_vtag" ; done'\'' ; set +o noglob'

#@ pwiz_reset_tags
#
# Alias for unsetting all tag variables. Prevent inheritance of tags
#to functions called from inside other function, where tag is defined.
# WARNING: This function reset all variables named pwiz_tag_*!
alias pwiz_reset_tags='unset ${!pwiz_tag_*} ; pwiz_default_tags'

#@ pwiz_reset_vtags
#
# Alias for unsetting all vtag variables. Prevent inheritance of tags
#to next function call.
# WARNING: This function reset all variables named pwiz_vtag_*!
alias pwiz_reset_vtags='unset ${!pwiz_vtag_*} ; pwiz_default_vtags'

#@ pwiz_register_tag_default pwiz_tag_tag=value
# pwiz_tag_tag=value: command to reset tags
#
# Because @pwiz_read_tags use global variables and functions need to
#recurse, there is no chance for simple predefining default value for
#tag as global variable. You have to use this function.
# Register default tag value.
function pwiz_register_tag_default {
    pwiz_tag="$1"
    pwiz_tag=${pwiz_tag//\'/\'\\\'\'}\'
    pwiz_tag=${pwiz_tag/=/=\'}
    pwiz_array_add pwiz_tagreset "pwiz_tag_$pwiz_tag"
    pwiz_array_add pwiz_vtagreset "pwiz_vtag_$pwiz_tag"
}
declare -a pwiz_tagreset
declare -a pwiz_vtagreset

# Default version inheritance of answers.
pwiz_register_tag_default inherit=80
# FIXME: Now probably obsolete.
# Credit level of unknown source.
pwiz_register_tag_default credit=50

pwiz_register_tag_default yesno=false
pwiz_register_tag_default allow_new=true
pwiz_register_tag_default no_default=false
pwiz_register_tag_default item_type=string
pwiz_register_tag_default valid=exact
pwiz_register_tag_default knowledge=general
pwiz_register_tag_default importance=25
pwiz_register_tag_default askmenu_hook=:
pwiz_register_tag_default callback=pwiz_question_enter_string
pwiz_register_tag_default callback_prompt="Your value: "
pwiz_register_tag_default multiline=false

#@ pwiz_default_tags
#
# After calling @pwiz_reset_tags, no tags are defined. To define
#default values, use this function.
function pwiz_default_tags {
    eval "${pwiz_tagreset[@]}"
}

function pwiz_default_vtags {
    eval "${pwiz_vtagreset[@]}"
}

# Simplifies reset procedure (list is not empty). Probably has no meaning.
pwiz_default_tags
pwiz_default_vtags

# FIXME: probably obsolete
# Default is undefined (definition prevents collision with empty string default).
#unset pwiz_tag_default
    # Credit level of automatic guesses.
    # FIXME: Should be dependent on knowledge tag.
#    pwiz_auto_guess=50


# @@Aliases
# @ Aliases must be here, otherwise are not valid for function
# definitions, but documentation is lower, where logically belongs.
alias pwiz_cache_validity_apply='local pwiz_cache_validity=pwiz_cache_validity_"$pwiz_tag_valid" ; if test "$(type -t "$pwiz_cache_validity")" != function ; then pwiz_fatal "invalid validitity range $pwiz_tag_valid (tag \"valid\")" ; fi ; $pwiz_cache_validity'
alias pwiz_keys_set='local pwiz_key ; for pwiz_key in $pwiz_key_list ; do local $pwiz_key ; eval $pwiz_key\=\$pwiz_project_$pwiz_key ; done'


#@@@ PWIZ engines

#@ $not_implemented
# PWIZ error code for not implemented functions (6).
not_implemented=6

#@@ Engine description
# Engine is a piece of bash code, sourced from PWIZ core. It typically
#implements an independent interface for communication with outer
#world.

#@ {engine_class}/{engine_name}.pwe [ command ]
# command: Command for engine.
#
# Run engine with command.
# Available commands:
# @"no command": Load engine.
# @desc: show description and return
# @longdesc: show long description and return

#@ pwiz_engine_{engine_class}_{engine_name}_{command} [ optional arguments ]
# engine_class: class of engine (only one in each class can be active)
# engine_name: name of engine (implementation of engine class)
#
# Engine must define all class specific functions defined by
#@pwiz_engine_interface plus @init and @quit.
# Engine functions are not called directly, but using
#@"pwiz_{engine_class}_{command} [ optional arguments ]".

#@ pwiz_engine_desc engine_class engine_name
# engine_class: class of engine (only one in each class can be active)
# engine_name: name of engine (implementation of engine class)
#
# Show description of engine implementation.
function pwiz_engine_desc {
    . @PW_DATADIR@/engines/$1/$2.pwe desc
}

#@ pwiz_engine_longdesc engine_class engine_name
# engine_class: class of engine (only one in each class can be active)
# engine_name: name of engine (implementation of engine class)
#
# Show long description of engine implementation.
function pwiz_engine_longdesc {
    . @PW_DATADIR@/engines/$1/$2.pwe longdesc
}

#@ pwiz_engine_load engine_class engine_name
# engine_class: class of engine (only one in each class can be active)
# engine_name: name of engine (implementation of engine class)
#
# Source engine (load function definitions to PWIZ) and define calling
#functions to use this engine.
function pwiz_engine_load {
    local interface i
    . @PW_DATADIR@/engines/$1/$2.pwe
    pwiz_engine_${1}_${2}_init
    pwiz_add_exit pwiz_engine_${1}_${2}_quit
    eval interface\=\"\$PWIZ_ENGINE_INTERFACE_$1\"
    for i in init quit $interface
    do
	eval function pwiz_${1}_${i} "{
	    eval pwiz_engine_${1}_${2}_${i} \\\"\\\$@\\\"
	}"
    done
}

#@ pwiz_engine_load engine_class engine_name
# engine_class: class of engine (only one in each class can be active)
# engine_name: name of engine (implementation of engine class)
#
# Source engine (load function definitions to PWIZ) and define calling
#functions to use this engine.

#@ pwiz_engine_list engine_class
# engine_class: class of engine (only one in each class can be active)
# returns: list of engines to stdout (FIXME will change to
#$pwiz_result in future versions)
#
# List all available engines of defined class.
function pwiz_engine_list {
    (
	cd @PW_DATADIR@/engines/$1
# FIXME not sed, use pwiz_result instead of redirection
	ls -1 | sed 's/\.pwe$//'
    )
}

#@ pwiz_engine_interface engine_class function1 [ function2 ... ]
# engine_class: class of engine (only one in each class can be active)
# function...: Required functions in defined engine_class.
#
# While defining new engine class, using @pwiz_engine_interface you
#define a list of function, which shall be provided by each engine of
#this class.
function pwiz_engine_interface {
    local class
    class=$1
    shift
    eval PWIZ_ENGINE_INTERFACE_$class\=\"\$\*\"
}

#@@ Cache engine
# Cache engine is designed for writing and reading answers and other
#useful information (tags) in per-package/version/product etc. basis.
#Address space is defined by keys. Keys are similar to filesystem
#paths. All functions returns result in $pwiz_result, if any
# WARNING: Cache engine functions are "low level" and not recommended
#for direct use by programmers. Use cache interface functions instead.

# FIXME: cache engine should test, whether all key items are non empty

#@ pwiz_cache_read key
# key: key for data you want to read from cache
#
# Read data associated with key from cache.

#@ pwiz_cache_read_tags key
# key: key for data you want to read from cache
#
# Read tags associated with key from cache.

# WARNING: pwiz_cache_read_tags reads all tags in single string. To
#get particular tags, it must be further expanded by @eval or
#@pwiz_read_tags.

#@ pwiz_cache_write key value [ tags ]
# key: key for data you want to write to cache
# value: data to be written
# tags: tags to be written
#
# Write data and tags to cache (associate data and tags with key).

#@ pwiz_cache_delete key
# key: key for data you delete from cache
#
# Delete data and tags from cache (unassociate data and tags with key).

#@ pwiz_cache_list pattern
# pattern: pattern for keys you want to query
# returns ${pwiz_result[@@]}: array of keys found (can be empty)
#
# Find all keys in cache which corresponds to defined pattern.
# NOTE: Patterns are standard path-element patterns (for globbing over
#more key elements you need to use more askerisks).
# WARNING: Implementation must support subpatterns at least for q
#element (i. e. not only "/*/", but also "/subkey*/".

pwiz_engine_interface cache read read_tags write delete list

#@@ Cache interface

# Cache user interface are high-level functions used for access to
#cache values. It has the same logical structure of addressing as ask
#interface. It is used, if you want to save some information in PWIZ
#cache, but don't need to ask user for anything.
# Use these function for saving information needed in next pwiz run
#for earlier stages.

#@ pwiz_cache_save value [ tags ... ]
# returns ${q tag}: value is stored to environment variable named as q
#tag
# uses tag q: question ID (required)
# uses tag credit: credit of saved value (default 100 - diffferent default from other functions!)
# uses tag valid: validity range (see @pwiz_cache_validity_{name}) (default=exact)
#
# Fuction for saving value to cache. Uses the same tag naming style as
#ask interface uses. You only have to specify q tag.
function pwiz_cache_save {
    local value=$1
    shift
    pwiz_reset_tags
    # Change the default credit to 100.
    pwiz_tag_credit=100
    pwiz_read_tags
    if test -z "$pwiz_tag_q" ; then
	pwiz_fatal "pwiz_cache_save called without q tag"
    fi
    pwiz_keys_set
    pwiz_cache_validity_apply
    pwiz_cache_write "$pwiz_tag_q/$project/$subproject/$version/$patchlevel/$vendor/$build" "$value" "$@"

    eval $pwiz_tag_q\=\"\$value\"
}

#@ pwiz_cache_remove value [ tags ... ]
# uses tag q: question ID (required)
# uses tag valid: validity range (see @pwiz_cache_validity_{name}) (default=exact)
#
# Fuction for deleting value from cache. Uses the same tag naming style as
#ask interface uses. You only have to specify q tag.
function pwiz_cache_remove {
    local value=$1
    shift
    pwiz_reset_tags
    pwiz_read_tags
    if test -z "$pwiz_tag_q" ; then
	pwiz_fatal "pwiz_cache_remove called without q tag"
    fi
    pwiz_keys_set
    pwiz_cache_validity_apply
    pwiz_cache_delete "$pwiz_tag_q/$project/$subproject/$version/$patchlevel/$vendor/$build"
}

#@ pwiz_cache_load value [ tags ... ]
# returns ${pwiz_guesses[@@]}: array of all acceptablee guesses found
# returns ${pwiz_credits[@@]}: array of credits of guesses
# returns $pwiz_guess_best: index of most credible guess
# returns $pwiz_guess_best_value: value of most credible guess ("@@PWIZ_UNDEFINED@@" if none)
# returns $pwiz_guess_best_credit: credit of best guess
# returns ${pwiz_strings[@@]}: array of string values of guesses (optional - array can be sparse)
# returns ${pwiz_hotkeys[@@]}: array of guess hotkeys (optional - array can be sparse)
# returns $pwiz_cache_key_value: cache value for exact match ("@@PWIZ_UNDEFINED@@" if none)
# returns $pwiz_cache_key_tags: cache tags for exact match (undefined if none)
# returns $pwiz_cache_key_credit: cached credit for exact match
# uses tag q: question ID (required)
# uses tag credit: credit of saved value (default 100 - diffferent default from other functions!)
# uses tag valid: validity range (see @pwiz_cache_validity_{name}) (default=exact)
# uses tag default: default value, used if no cached guess is available
#
# Fuction for reading value from cache. Uses the same tag naming style
#as ask interface uses, including guessing and answer credit. You have
#to specify q tag.
# WARNING: In difference to ask interface and @pwiz_cache_save, value
#is not cached in local variable. It is because you can want read best
#guess or exact guess.
function pwiz_cache_load {
    pwiz_reset_tags
    pwiz_read_tags
    if test -z "$pwiz_tag_q" ; then
	pwiz_fatal "pwiz_cache_remove called without q tag"
    fi
    pwiz_keys_set
    pwiz_cache_validity_apply
    local pwiz_cache_key="$pwiz_tag_q/$project/$subproject/$version/$patchlevel/$vendor/$build"

    # Add '*' to pattern for keys, where credit inheritance function exists.
    # This is really needed in pwiz_guess, but it's simpler to set it here.
    for pwiz_key in $pwiz_key_list ; do
	if test "$(type -t "pwiz_guess_credit_$pwiz_key")" = function ; then
	    eval $pwiz_key\=\'\*\'
	fi
    done
    pwiz_cache_validity_apply

    decho_guess "cache load tags: $*"
    if ! test -z "$pwiz_tag_q" ; then
	eval pwiz_answer\=\"\${$pwiz_tag_q-@@PWIZ_UNDEFINED@@}\"
	if test "$pwiz_answer" != @@PWIZ_UNDEFINED@@ ; then
	    decho_guess "cache already loaded: $pwiz_answer"
	    return
	fi
    fi
    pwiz_guess
}


#@@ Pkgdb engine
# This engine provides interface with package database on destination
#system.

#@ pwiz_pkgdb_what_owns file [ ... ]
# file: queried file
# returns: 0: OK, 1: problem
# returns ${pwiz_result[@@]}: array of owning packages
#
# Ask package database, which of installed packages owns file.

# FIXME: Does it need implementation?
# pwiz_pkgdb_package_to_project package
# returns $pwiz_result: list of packages owning file or directory
#
# (can be more items at once)

pwiz_engine_interface pkgdb what_owns

#@@ Question engine
# Question engine is interface for communication with users. Engine
#asks user and waits for response.
# Any question can contain callback functions (which can be
#implementation alternative interface for "enter manually").
# WARNING: This is an internal class of engines and programmers should
#not use these functions directly. Use @pwiz_ask_{function} instead.
#Those functions do additional answer caching and guess evaluation.

#@ pwiz_question_enter_string initial_value
# initial_value: initial value of string
# returns $pwiz_answer: user's answer
# can use tag prompt: prompt for manual answer (default "Your value: ")
#
# Prompt user for string.

#@ pwiz_question_string desc longdesc [ tags ... ]
# returns $pwiz_answer: user's answer
# returns $pwiz_fallback_answer: user selected default answer (default false)
# uses tag no_default: no preselected default - user have to respond
#(default false)
# can use tag multiline: allow multiple-line strings (default false)
#
# Interface to ask user for string. Alternating this interface, you
#can also obtain radio: @allow_new=false, yes/no: @yesno=true.

#@ pwiz_question_list desc longdesc [ tags ... ]
# returns $pwiz_answer: user's answer
# returns $pwiz_fallback_answer: user selected default answer (default false)
# uses tag allow_new: if set to false, "enter manually" is disabled
#(default true)
# uses tag askmenu_hook: hook function for adding items to askmenu
#(default is nop)
# uses tag no_default: no preselected default - user have to respond
#(default false)
# uses tag callback: callback function for "enter manually" (returns
#$pwiz_answer) (default string)
# uses tag item_type: type of item for asking "new item" (default
#string)
#
# Interface to ask user for a selection from list.

# pwiz_question_radio desc longdesc [ tags ... ]
# Returns: $pwiz_answer with selection.
# pwiz_question_selection desc longdesc [ tags ... ]
# Returns: FIXME

# FIXME: pwiz_ask_radio is obsolete use ask_string with allow_new=false
#pwiz_engine_interface question radio selection string list
pwiz_engine_interface question enter_string question radio selection string list auto_answer

# Question engine is in most cases used through ask interface. It
# accomplishes question, caching answer and querying for reasonable
# guesses.

#@@@ Asking interface and guesses
# Asking interface is used for querying users, saving and re-using
#results. It is based on question interface and is intended for use by
#programmers.
# Guessing uses cached answers for searching answers to new questions.

#@@ Cache keys
# Cache keys are used for addressing entries in cache.

#@ $pwiz_key_list
# List of keys for question id (in order). Currently "project
#subproject version patchlevel vendor build".
# NOTE: For cache queries, first path item is question id.
pwiz_key_list="project subproject version patchlevel vendor build"

#@ project
#
# Name of project (package).

#@ subproject
#
# Name of subproject. Normally unused ("-"), but can contain
#subpackage or partial project name.

#@ version
#
# Version of source codes.

#@ patchlevel
#
# Patch level. Additional resolution above source version.

#@ vendor
#
# Vendor+product string. Needed to discriminate between different
#packaging solutions for different vendors and products.

#@ build
#
# Build number. Needed to discriminate exact environment used for
#build (other package was updated, change in package is needed).

#@ pwiz_keys_set
#
# Alias for cloning global variables $pwiz_project_{key} to local
#variables ${key}. It is used by functions, which need to alter these
#values internally.

# See definition upper, where it must be due to alias axpansion.

#@@ Cache validities
# When searching guess for question, PWIZ needs to run through all
#similar answers. Question has its validity range. If asked again, and
#valid keys are identical, answer is considered as valid.

#@ pwiz_cache_validity_{name}
# returns: "@@" in key variables considered invalid for range
# 
# Validity ranges can be defined by programmers of modules. To define
#validity range name (used in tags as "valid={name}"), you should
#define function pwiz_cache_validity_{name}.

#@ pwiz_cache_validity_apply
#
# Remove cahe keys, where exact match will be required. Removes values
#unappropriate for defined validity range - if there is no function to
#compare similarity, key is removed and exact key match will be
#required.

# See definition upper, where it must be due to alias axpansion.

#@ pwiz_cache_validity_exact
#
# Exact match in query is required. Use "valid=exact" in question to
#use this validity range (this is the default).
function pwiz_cache_validity_exact {
    :
}

#@ pwiz_cache_validity_source
#
# Match for all keys using the same source codes. Valid are all keys
#except @patchlevel, @vendor and @build. Useful for checking of
#unpacked sources. Use "valid=source" in question to use this validity
#range.
function pwiz_cache_validity_source {
    patchlevel=@
    vendor=@
    build=@
}

#@ pwiz_cache_validity_setup
#
# Value for PWIZ setup. No keys are valid. Used for PWIZ preferences.
#Use "valid=setup" in question to use this validity range.
function pwiz_cache_validity_setup {
    project=@
    subproject=@
    version=@
    patchlevel=@
    vendor=@
    build=@
}

#@ pwiz_cache_validity_project
#
# Per-project information, independent on vendor. Only key @project is
#valid. Use "valid=project" in question to use this validity range.
function pwiz_cache_validity_project {
    subproject=@
    version=@
    patchlevel=@
    vendor=@
    build=@
}

#@ pwiz_cache_validity_projectstate
#
# Project state information, dependent on vendor. Keys @project,
#@subproject and @vendor are valid. Use "valid=projectstate" in
#question to use this validity range. Used for special purposes, like
#storing patchlevel.
function pwiz_cache_validity_projectstate {
    version=@
    patchlevel=@
    build=@
}

#@ pwiz_cache_validity_vendor
#
# Vendor's policy, independent on project (package). Only key @vendor
#is valid. Use "valid=vendor" in question to use this validity range.
function pwiz_cache_validity_vendor {
    project=@
    subproject=@
    version=@
    patchlevel=@
    build=@
}

#@ pwiz_cache_validity_product
#
# Vendor's policy for project (package). Valid keys are @project
#and @vendor. Use "valid=product" in question to use this validity
#range.
function pwiz_cache_validity_product {
    subproject=@
    version=@
    patchlevel=@
    build=@
}

#@@ Inherited credibility
# Outside validity range, answer cannot be considered as fully
#credible. But not taking such answer in account means repeated
#answering the same question for all version. That's why there is
#credit inheritance. Answer is accepted, but its credit is decreased.
# Guess credit level functions are functions define ability to trust
#answers, which based on comparison of particular keys of both
#questions.

pwiz_debug_feature guess "internals of guessing" "This feature turns on displaying of single steps in making a guess."

#@ pwiz_guess_credit_{key}
# returns $pwiz_credit: inherited credibility
# uses $pwiz_project_{key}: key for current project
# uses $pwiz_item_{key}: key for cached project
#
# Iherited credibility functions can be defined by programmers of
#modules. To define own guess credit level function, you need to
#define function pwiz_guess_credit_{key}. Credit level function has
#access to other key values, which can be used for guess, too.
# Function compares keys in variables $pwiz_project_{key} and
#$pwiz_item_{key}.
# Returns value 0-100 in $pwiz_credit.

#@ $pwiz_credit
# Return value for inherited credibility value.

#@ pwiz_guess_credit_version
# returns $pwiz_credit: inherited credibility
# uses tag inherit: inheritance between versions (default 80)
#
# Credit inheritance level between versions. Using tag inherit you can
#increase or decrease default credibility of answer done in other
#version.
function pwiz_guess_credit_version {
    if test "$pwiz_project_version" = "$pwiz_item_version" ; then
	pwiz_credit=100
    else
	pwiz_credit=$pwiz_tag_inherit
    fi
}

# pwiz_guess_credit (internal function)
#
# Computes credit value based on inherited credibility.
function pwiz_guess_credit {
    local pwiz_key subcredit=$pwiz_vtag_credit
    for pwiz_key in $pwiz_key_list ; do
	if test "$(type -t "pwiz_guess_credit_$pwiz_key")" = function ; then
	    eval pwiz_guess_credit_$pwiz_key
	    let subcredit=subcredit\*pwiz_credit/100
	fi
    done
    pwiz_credit=$subcredit
}

#@ pwiz_guess [ tags ]
# returns ${pwiz_guesses[@@]}: array of all acceptablee guesses found
# returns ${pwiz_credits[@@]}: array of credits of guesses
# returns $pwiz_guess_best: index of most credible guess
# returns $pwiz_guess_best_value: value of most credible guess
# returns $pwiz_guess_best_credit: credit of best guess
# returns ${pwiz_strings[@@]}: array of string values of guesses (optional - array can be sparse)
# returns ${pwiz_hotkeys[@@]}: array of guess hotkeys (optional - array can be sparse)
# returns $pwiz_cache_key_value: cache value for exact match ("@@PWIZ_UNDEFINED@@" if none)
# returns $pwiz_cache_key_tags: cache tags for exact match (undefined if none)
# returns $pwiz_cache_key_credit: cached credit for exact match
#(without cache source credit applied) (undefined if none)
# uses tag q: question ID
# uses tag default[@@]: predefined defaults
# uses tag c[@@]: credits of predefined defaults (optional - array can be sparse)
# uses tag string[@@]: string value for predefined defaults (optional - array can be sparse)
# uses tag hotkey[@@]: guess hotkey for predefined defaults (optional - array can be sparse)
# uses tag valid: validity range (see @pwiz_cache_validity_{name}) (default exact)
# uses tag yesno: tag for boolean questions (default false)
# uses $pwiz_cache_key: cache key name, where answer should be cached (required)
# uses ${pwiz_guess_default_{tag q}[@@]}: predefined defaults in variables
# uses ${pwiz_guess_c_{tag q}[@@]}: credits of predefined defaults in
#variables (optional - array can be sparse)
# uses ${pwiz_guess_string_{tag q}[@@}]: string value for predefined
#defaults in variables (optional - array can be sparse)
# uses ${pwiz_guess_hotkey_{tag q}[@@]}: guess hotkey for predefined
#defaults in variables (optional - array can be sparse)
#
# This function collects all available guesses. Function is used
#internally by @pwiz_ask_core.
function pwiz_guess {
    local key_found is_new tags count v_total v_default v_c v_string v_hotkey callback

    # Imported local variables:
    # pwiz_guesses pwiz_credits pwiz_strings pwiz_hotkeys

    # Defaults for Boolean.
    if $pwiz_tag_yesno ; then
	pwiz_guess_eval false 0 "no" n
	pwiz_guess_eval true  0 "yes" y
    fi

    # callback of pwiz_guess_callback_{q}[*]
    if ! test -z "$pwiz_tag_q" ; then
	eval 'for callback in ${pwiz_guess_callback_'"$pwiz_tag_q"'[@]} ; do
	    $callback
	done'
    fi

    # parse guesses in tags
    for (( count=0 ; count < ${#pwiz_tag_default[@]} ; count++ )) ; do
	decho_guess "guess in tags: ${pwiz_tag_default[count]} (${pwiz_tag_c[count]:-0}c)"
	pwiz_guess_eval "${pwiz_tag_default[count]}" "${pwiz_tag_c[count]}"\
	    "${pwiz_tag_string[count]}" "${pwiz_tag_hotkey[count]}"
    done

    if ! test -z "$pwiz_tag_q" ; then

	# parse guesses in environment variables pwiz_guess_default_{q}, pwiz_guess_string_{q} pwiz_guess_hotkey_{q}
	# WARNING: Those quesses does not recomputed p
	eval v_total\=\${#pwiz_guess_default_$pwiz_tag_q\[@\]}
	for (( count=0 ; count < v_total ; count++ )) ; do
	    eval v_default\=\"\${pwiz_guess_default_$pwiz_tag_q\[count\]}\"
	    eval v_c\=\${pwiz_guess_c_$pwiz_tag_q\[count\]}
	    eval v_string\=\"\${pwiz_guess_string_$pwiz_tag_q\[count\]}\"
	    eval v_hotkey\=\"\${pwiz_guess_hotkey_$pwiz_tag_q\[count\]}\"
	    decho_guess "guess in variable: $v_default (${v_c:-0}c)"
	    pwiz_guess_eval "$v_default" "$v_c" "$v_string" "$v_hotkey"
	done

	# parse cached guesses
	pwiz_cache_key_value=@@PWIZ_UNDEFINED@@
	pwiz_cache_key_tags=
	pwiz_cache_key_credit=-1
	# FIXME: In future implement credits of cache sources.
	decho_guess "cache query:  $pwiz_tag_q/$project/$subproject/$version/$patchlevel/$vendor/$build"
	pwiz_cache_list "$pwiz_tag_q/$project/$subproject/$version/$patchlevel/$vendor/$build"
	for key_found in $pwiz_result ; do
	    decho_guess "found: $key_found"
	    pwiz_key_parse $key_found
	    pwiz_cache_read_tags $key_found
	    tags="$pwiz_result"
	    pwiz_cache_read $key_found
	    pwiz_reset_vtags
	    pwiz_read_vtags
	    if test $key_found = $pwiz_cache_key ; then
# FIXME: In future, this will contain value from default cache writing resource.
		pwiz_cache_key_value="$pwiz_result"
		pwiz_cache_key_tags="$tags"
		pwiz_cache_key_credit="$pwiz_vtag_credit"
	    fi
	    pwiz_guess_credit
# FIXME: Maybe parse tags to find string and hotkey.
# FIXME: Maybe implement allow_inherited_tags=true to allow to parse tags in old values.
	    pwiz_guess_eval "$pwiz_result" "$pwiz_credit" "" ""
	    decho_guess "result: $pwiz_result (${pwiz_credit:-0}c)"
	done

    fi

    pwiz_guess_best_value=@@PWIZ_UNDEFINED@@
    pwiz_guess_best_credit=-1
    pwiz_guess_best=-1

    for (( count=0 ; count < ${#pwiz_guesses[*]} ; count++ )) ; do
	decho_guess "guess[$count]: \"${pwiz_guesses[count]}\" (${pwiz_credits[count]}c)"
	# Evaluate best guess.
	if test ${pwiz_credits[count]} -ge $pwiz_guess_best_credit ; then
	    pwiz_guess_best_credit=${pwiz_credits[count]}
	    pwiz_guess_best=$count
	    pwiz_guess_best_value="${pwiz_guesses[count]}"
	fi
    done
    decho_guess "available guesses: ${#pwiz_guesses[*]}"
    decho_guess "best guess $pwiz_guess_best: $pwiz_guess_best_value"
    decho_guess "best guess credit: $pwiz_guess_best_credit"
}

#@ pwiz_guess_eval guess credit string hotkey
# guess: value of guess
# credit: credit of guess (can be empty string)
# string: string value for guess (can be empty string)
# hotkey: guess hotkey (can be empty string)
#
# This internal function evaluates guess and optionally adds it to
#guess array in @pwiz_guess.
function pwiz_guess_eval {
    local count
    local size=${#pwiz_guesses[@]}
    local is_new=true
    for (( count=0 ; count < size ; count++ )) ; do
	if test "${pwiz_guesses[count]}" = "$1" ; then
	    # If current credit is higher than previous, use current one.
	    # If guess does not provide credit, assume 0.
	    if test ${2:-0} -gt ${pwiz_credits[count]} ; then
		pwiz_credits[count]=${2:-0}
	    fi
	    is_new=false
	    break
	fi
    done
# FIXME: Maybe test -z is not required.
    if $is_new ; then
	pwiz_credits[size]=${2:-0}
	if ! test -z "$3" ; then
	    pwiz_strings[size]="$3"
	fi
	if ! test -z "$4" ; then
	    pwiz_hotkeys[size]="$4"
	fi
	pwiz_array_add pwiz_guesses "$1"
    else
	if test -z "${pwiz_strings[count]}" -a ! -z "$3" ; then
	    pwiz_strings[count]="$3"
	fi
	if test -z "${pwiz_hotkeys[count]}" -a ! -z "$4" ; then
	    pwiz_hotkeys[count]="$4"
	fi
    fi
}

#@ pwiz_guess_add id guess credit string hotkey
# q: question ID (corresponds to tag q)
# guess: value of guess
# credit: credit of guess (can be empty string)
# string: string value for guess (can be empty string)
# hotkey: guess hotkey (can be empty string)
#
# Add a guess to environment variables ${pwiz_guess_default_{q}},
#${pwiz_guess_c_{q}}, ${pwiz_guess_p_{q}} and
#${pwiz_guess_string_{q}}. Later @pwiz_guess can take it in account.
# NOTE: Credit is considered as absolute. No user credibility is
#evaluated.
function pwiz_guess_add {
    eval local count\=\${#pwiz_guess_default_$1\[@\]}
    eval pwiz_guess_default_$1\[count\]\=\"\$2\"
    eval pwiz_guess_c_$1\[count\]\=\"\$3\"
    if ! test -z "$4" ; then
	eval pwiz_guess_string_$1\[count\]\=\"\$4\"
    fi
    if ! test -z "$5" ; then
	eval pwiz_guess_hotkey_$1\[count\]\=\"\$5\"
    fi
}

#@ pwiz_key_parse key
# key: cache key to parse
# returns pwiz_item_{key}: particular keys
#
# Parses cache key to its elements and assigns it to variables
#$pwiz_item_q and $pwiz_item_{key}, where key is from $pwiz_key_list.
function pwiz_key_parse {
    local keys pwiz_key
    keys=$1
    for pwiz_key in q $pwiz_key_list ; do
	eval pwiz_item_$pwiz_key\=\${keys%%/\*}
	keys=${keys#*/}
    done
}

#@@ Askmenu
# Askmenu is a structure between question interface and question
#backend. It helps with menu construction and processing answer.
# Expanation of variables:
# @${pwiz_askmenu_callbacks[@@]}: Callbacks, called when menu item is
#selected. Used internally. Must be defined.
# @${pwiz_askmenu_ids[@@]}: id for preselection and postselection
#callbacks (can be empty string)
# @${pwiz_askmenu_strings[@@]}: Strings to be displayed by question
#back-end. Should not be empty.
# @${pwiz_askmenu_hotkeys[@@]}: Hotkeys. Displayed by question
#back-end. Used by @pwiz_preselection_callback_default for hotkey
#(abbreviation) recognition. Other preselection callbacks can use it
#in other way (or not at all), but string contents can be still
#displayed by question back-end.
# @${pwiz_askmenu_preselection_callbacks[@@]}: Callback called to
#decide, whether user selected this menu item. Default is
# @${pwiz_askmenu_preselection_numbers[@@]}: Order numbers for ordered
#items.
# @${pwiz_askmenu_preselection_number_indexes[@@]}: Reverse index,
#which maps ordered list index to askmenu index.
# Minimal example of building menu with menu hook and processing
#answer:
#@<
#function help_func {
#    echo "This is a help text for $1."
#    # We want to display question again.
#    return 1
#}
#function help_hook {
#    pwiz_askmenu_add help_func test_dialog Help   h
#}
#pwiz_askmenu_add_hook help_hook
#
#pwiz_askmenu_reset
#pwiz_askmenu_add echo reply_was_bottom   Bottom   ""
#pwiz_askmenu_add echo reply_was_fallback Fallback "" pwiz_preselection_callback_fallback_default tail
#pwiz_askmenu_add echo reply_was_1        One      a  ""     head
#pwiz_askmenu_add echo reply_was_2        Two      b  ""     is_default head
#pwiz_askmenu_add echo reply_was_3        Strange  cc ""     head no_number
#pwiz_askmenu_complete
#
#for (( count=0 ; count < ${#pwiz_askmenu_callbacks[@]} ; count++ )) ; do
#    echo -n "$count, ${pwiz_askmenu_hotkeys[count]}: ${pwiz_askmenu_strings[count]}"
#    if test $count = $pwiz_askmenu_default ; then
#	echo -n " (default)"
#    fi
#    echo
#done
#read -p "Please answer: "
#pwiz_askmenu_process "$REPLY"
#case $? in
#    0 )
#	echo OK
#	;;
#    1 )
#	echo menu should be displayed again
#	;;
#    2 )
#	echo failed
#esac
#@>

declare -a pwiz_askmenu_build_callbacks
declare -a pwiz_askmenu_build_ids
declare -a pwiz_askmenu_build_strings
declare -a pwiz_askmenu_build_hotkeys
declare -a pwiz_askmenu_build_preselection_callbacks
declare -a pwiz_askmenu_build_flags

declare -a pwiz_askmenu_build_hooks

declare -a pwiz_askmenu_callbacks
declare -a pwiz_askmenu_ids
declare -a pwiz_askmenu_strings
declare -a pwiz_askmenu_hotkeys
declare -a pwiz_askmenu_preselection_callbacks
declare -a pwiz_askmenu_numbers
declare -a pwiz_askmenu_number_indexes

#@ pwiz_askmenu_add {pwiz_askmenu_function} id string hotkey {preselection_callback} [ flags ... ]
# {pwiz_askmenu_function}: function, which will be called, if user
#selects this item
# id: identification of askmenu item (can be empty string,
#if @{pwiz_askmenu_function} does not require it)
# string: short description of feature (must not be empty)
# hotkey: guess hotkey (can be empty string)
# {preselection_callback}: callback called while evaluating answer
#(can be empty string, then @pwiz_preselection_callback_default is
#used; can be @pwiz_preselection_callback_fallback_default, then all
#answers will be accepted - useful only for tail element)
# flags: "is_default": this menu entry is default, "head": show in
#first part of the list, "tail": show in last part of the list,
#"no_number": entry is not numbered
#
# Add an item to ask menu. If item is selected by
#user, @{pwiz_askmenu_function} is called.

#@ {pwiz_askmenu_function} id answer
# id: identification of askmenu item from @pwiz_askmenu_add (can be
#empty string)
# answer: user's answer
# returns: 0: processed, 1: menu should be displayed again
#
# This function is called, if user selects this item.

#@ {preselection_callback} id index answer
# id: identification of askmenu item from @pwiz_askmenu_add (can be
#empty string)
# index: current index in following arrays: @${pwiz_askmenu_callbacks[@@]}, @${pwiz_askmenu_ids[@@]}, @${pwiz_askmenu_strings[@@]}, @${pwiz_askmenu_hotkeys[@@]}, @${pwiz_askmenu_numbers[@@]}, @${pwiz_askmenu_preselection_callbacks[@@]}
# answer: user's answer
# returns: 0: it is item selected by user, 1: it is not item selected by user
#
# Callback function, called during evaluation of user answer. Default
#callback is @pwiz_preselection_callback_default.

function pwiz_askmenu_add {
    local i hotkey_free=true
    pwiz_array_add pwiz_askmenu_build_callbacks "$1"
    pwiz_array_add pwiz_askmenu_build_ids "$2"
    pwiz_array_add pwiz_askmenu_build_strings "$3"
    for (( i=0 ; i < ${#pwiz_askmenu_build_hotkeys[@]} ; i++ )) ; do
	if test "$4" = "${#pwiz_askmenu_build_hotkeys[@]}" ; then
	    hotkey_free=false
	    break
	fi
    done
    if $hotkey_free ; then
	pwiz_array_add pwiz_askmenu_build_hotkeys "$4"
    else
	# FIXME: Maybe implement alternative hotkey
	pwiz_array_add pwiz_askmenu_build_hotkeys ""
    fi
    pwiz_array_add pwiz_askmenu_build_preselection_callbacks "${5:-pwiz_preselection_callback_default}"
    if test $# -gt 4 ; then
	shift 5
	pwiz_array_add pwiz_askmenu_build_flags "$*"
    else
	pwiz_array_add pwiz_askmenu_build_flags ""
    fi
}

#@ pwiz_askmenu_add_hook {pwiz_askmenu_hook}
# {pwiz_askmenu_hook}: hook function, which calls @pwiz_askmenu_add on its own
#
# Add hook function, which is called every time pwiz wants to create
#ask menu.

#@ {pwiz_askmenu_hook}
#
# uses: $pwiz_tags_{tag}: tags are already read to variables
#using @pwiz_read_tags.
#
# This function is called every time ask menu is created. Hook
#function can look at tags and decide, whether to display any menu
#item and call @pwiz_askmenu_add.

function pwiz_askmenu_add_hook {
    pwiz_array_add pwiz_askmenu_build_hooks "$1"
}

#@ pwiz_askmenu_reset
#
# Reset ask menu values. Called before building ask menu, Then
#appropriate @pwiz_askmenu_add are called. Process is finished
#by @pwiz_askmenu_complete.
function pwiz_askmenu_reset {
    unset pwiz_askmenu_build_callbacks
    unset pwiz_askmenu_build_strings
    unset pwiz_askmenu_build_hotkeys
    unset pwiz_askmenu_build_flags
    unset pwiz_askmenu_build_preselection_callbacks
}

#@ pwiz_askmenu_complete [ "no_hooks" ]
# "no_hooks": set if hooks should not be executed
# returns ${pwiz_askmenu_strings[@@]}: array of ask menu strings
# returns ${pwiz_askmenu_hotkeys[@@]}: array of ask menu hotkeys
# returns ${pwiz_askmenu_callbacks[@@]}: array of ask menu callbacks (internal)
# returns ${pwiz_askmenu_ids[@@]}: ids for ask menu callbacks and preselection callbacks
# returns ${pwiz_askmenu_preselection_callbacks[@@]}: array of ask menu preselection callbacks (internal)
# returns ${pwiz_askmenu_numbers[@@]}: array of ordered item numbers
# returns ${pwiz_askmenu_number_indexes[@@]}: reverse mapping of item numbers to askmenu indexes
# returns $pwiz_askmenu_default: index of default ask menu item
# returns $pwiz_askmenu_count: number of last numbered item plus 1
#
# Finishes ask menu building process. Called after @pwiz_askmenu_reset
#and all appropriate @pwiz_askmenu_add.
function pwiz_askmenu_complete {
    local count dcount=0 tmp tmp2

    unset pwiz_askmenu_callbacks
    unset pwiz_askmenu_ids
    unset pwiz_askmenu_strings
    unset pwiz_askmenu_hotkeys
    unset pwiz_askmenu_numbers
    unset pwiz_askmenu_number_indexes
    unset pwiz_askmenu_preselection_callbacks
    pwiz_askmenu_count=0

    if test "$1" != "no_hooks" ; then
	for (( count=0 ; count < ${#pwiz_askmenu_build_callbacks[@]} ; count++ )) ; do
	    ${pwiz_askmenu_build_hooks[count]}
	done
    fi

# FIXME: Verify unique hotkeys, create hotarray
    for (( count=0 ; count < ${#pwiz_askmenu_build_callbacks[@]} ; count++ )) ; do
	tmp=" ${pwiz_askmenu_build_flags[count]} "
	tmp2=${tmp/ head / }
	if test "$tmp" != "$tmp2" ; then
	    pwiz_askmenu_callbacks[dcount]=${pwiz_askmenu_build_callbacks[count]}
	    pwiz_askmenu_ids[dcount]=${pwiz_askmenu_build_ids[count]}
	    pwiz_askmenu_strings[dcount]=${pwiz_askmenu_build_strings[count]}
	    pwiz_askmenu_hotkeys[dcount]=${pwiz_askmenu_build_hotkeys[count]}
	    pwiz_askmenu_preselection_callbacks[dcount]=${pwiz_askmenu_build_preselection_callbacks[count]}
	    if test "$tmp" != "${tmp/ is_default /}" ; then
		pwiz_askmenu_default=$dcount
	    fi
	    if test "$tmp" = "${tmp/ no_number /}" ; then
		pwiz_askmenu_numbers[dcount]=$pwiz_askmenu_count
		pwiz_askmenu_number_indexes[pwiz_askmenu_count]=$dcount
		let pwiz_askmenu_count++
	    fi
	    let dcount++
	fi
    done
    for (( count=0 ; count < ${#pwiz_askmenu_build_callbacks[@]} ; count++ )) ; do
	tmp=" ${pwiz_askmenu_build_flags[count]} "
	tmp2=${tmp/ head / }
	tmp2=${tmp2/ tail / }
	if test "$tmp" = "$tmp2" ; then
	    pwiz_askmenu_callbacks[dcount]=${pwiz_askmenu_build_callbacks[count]}
	    pwiz_askmenu_ids[dcount]=${pwiz_askmenu_build_ids[count]}
	    pwiz_askmenu_strings[dcount]=${pwiz_askmenu_build_strings[count]}
	    pwiz_askmenu_hotkeys[dcount]=${pwiz_askmenu_build_hotkeys[count]}
	    pwiz_askmenu_preselection_callbacks[dcount]=${pwiz_askmenu_build_preselection_callbacks[count]}
	    if test "$tmp" != "${tmp/ is_default /}" ; then
		pwiz_askmenu_default=$dcount
	    fi
	    if test "$tmp" = "${tmp/ no_number /}" ; then
		pwiz_askmenu_numbers[dcount]=$pwiz_askmenu_count
		pwiz_askmenu_number_indexes[pwiz_askmenu_count]=$dcount
		let pwiz_askmenu_count++
	    fi
	    let dcount++
	fi
    done
    for (( count=0 ; count < ${#pwiz_askmenu_build_callbacks[@]} ; count++ )) ; do
	tmp=" ${pwiz_askmenu_build_flags[count]} "
	tmp2=${tmp/ tail / }
	if test "$tmp" != "$tmp2" ; then
	    pwiz_askmenu_callbacks[dcount]=${pwiz_askmenu_build_callbacks[count]}
	    pwiz_askmenu_ids[dcount]=${pwiz_askmenu_build_ids[count]}
	    pwiz_askmenu_strings[dcount]=${pwiz_askmenu_build_strings[count]}
	    pwiz_askmenu_hotkeys[dcount]=${pwiz_askmenu_build_hotkeys[count]}
	    pwiz_askmenu_preselection_callbacks[dcount]=${pwiz_askmenu_build_preselection_callbacks[count]}
	    if test "$tmp" != "${tmp/ is_default /}" ; then
		pwiz_askmenu_default=$dcount
	    fi
	    if test "$tmp" = "${tmp/ no_number /}" ; then
		pwiz_askmenu_numbers[dcount]=$pwiz_askmenu_count
		pwiz_askmenu_number_indexes[pwiz_askmenu_count]=$dcount
		let pwiz_askmenu_count++
	    fi
	    let dcount++
	fi
    done
}

#@ pwiz_preselection_callback_default id index answer
# id: identification of askmenu item from @pwiz_askmenu_add (can be
#empty string, usused)
# index: current index in following arrays: @${pwiz_askmenu_callbacks[@@]}, @${pwiz_askmenu_ids[@@]}, @${pwiz_askmenu_strings[@@]}, @${pwiz_askmenu_hotkeys[@@]}, @${pwiz_askmenu_numbers[@@]}, @${pwiz_askmenu_preselection_callbacks[@@]}
# answer: user's answer
# returns: 0: it is item selected by user, 1: it is not item selected by user
#
# Default @{preselection_callback} function. If user answers proper
#number or hotkey or answer is default and string is empty, answer is accepted.
function pwiz_preselection_callback_default {
    if test "$3" = "" ; then
	if test $2 = "$pwiz_askmenu_default" ; then
	    return 0
	fi
    else
	if test "$3" = "${pwiz_askmenu_numbers[$2]}" ; then
	    return 0
	else
	    if test "$3" = "${pwiz_askmenu_hotkeys[$2]}" ; then
		return 0
	    fi
	fi
    fi
    return 1
}

# FIXME: documentation of function @{function} -> @{{function}} to be displayed as italic "{function}".
# Also FIXME half italic ${pwiz_askmenu_callbacks[@]}, should be @{${pwiz_askmenu_callbacks[@]}} or so

#@ pwiz_preselection_callback_cnumber id index answer
# id: identification of askmenu item from @pwiz_askmenu_add (can be
#empty string)
# index: current index in following arrays: @${pwiz_askmenu_callbacks[@@]}, @${pwiz_askmenu_ids[@@]}, @${pwiz_askmenu_strings[@@]}, @${pwiz_askmenu_hotkeys[@@]}, @${pwiz_askmenu_numbers[@@]}, @${pwiz_askmenu_preselection_callbacks[@@]}
#(unused)
# answer: user's answer
# id: identification of askmenu item from @pwiz_askmenu_add (can be
#empty string, usused)
# uses $pwiz_preselection_callback_cnumber_maxval: maximal number,
#which is acccepted plus 1 (-1=no limit)
# returns: 0: it is item selected by user, 1: it is not item selected by user
#
# This @{preselection_callback} allows to use hotkeys in form
#@{{character}{number}}. function. If user answers proper number,
#answer is accepted. Number must be non-negative integer. Answer
#cannot be default (default does not contain number).
function pwiz_preselection_callback_cnumber {
    shopt -s extglob
    local tmp
    if test "${3:0:1}" = "${pwiz_askmenu_hotkeys[$2]:0:1}" ; then
	tmp="${3:1}"
	if test "${tmp%%*([0-9])}" = "" ; then
	    if test $tmp -lt $pwiz_preselection_callback_cnumber_maxval -o\
		$pwiz_preselection_callback_cnumber_maxval = -1 ; then
		shopt -u extglob
		return 0
	    fi
	fi
    fi
    shopt -u extglob
    return 1
}
pwiz_preselection_callback_cnumber_maxval=-1

#@ pwiz_preselection_callback_fallback_default index answer
# index: current index in following arrays: @${pwiz_askmenu_callbacks[@@]}, @${pwiz_askmenu_ids[@@]}, @${pwiz_askmenu_strings[@@]}, @${pwiz_askmenu_hotkeys[@@]}, @${pwiz_askmenu_numbers[@@]}, @${pwiz_askmenu_preselection_callbacks[@@]}
# answer: user's answer
# returns: 0: it is item selected by user
#
# Fallback @{preselection_callback}, which accepts all answers. Useful
#only for tail menu element.
function pwiz_preselection_callback_fallback_default {
    return 0
}

# FIXME: maybe index is number or hotkey

#@ pwiz_askmenu_process answer
# answer: answer from backend
# returns: 0: OK, 1: menu should be displayed again, 2: unknown selection
#
# After returning from backend, pwiz_askmenu_process is started to
#process selected value.
function pwiz_askmenu_process {
    local index=$1

    for (( index=0 ; index < ${#pwiz_askmenu_callbacks[@]} ; index++ )) ; do
	if ${pwiz_askmenu_preselection_callbacks[index]} "${pwiz_askmenu_ids[$index]}" $index "$1" ; then
	    ${pwiz_askmenu_callbacks[index]} "${pwiz_askmenu_ids[index]}" "$1"
	    return $?
	fi
    done
    return 2
}

#@@ Asking user

#@ pwiz_ask_{function} desc longdesc [ tags ]
# desc: short description of feature
# longdesc: long description of feature
# tags: optional tags
#
# Functions for asking user. These function are intended for module
#programmers.
# NOTE: During parsing of arguments of pwiz_ask_{function}, globbing
#is temporarilly turned off. It prevents accidental expansion of
#"tag[number]=*", especially in nullglob mode.

# dummy function for list tag item_type=none
# FIXME: Should disappear in future.
function pwiz_ask_none {
    :
}

#@ pwiz_ask_yesno desc longdesc [ tags ]
# desc: short description of feature
# longdesc: long description of feature
# tags: optional tags
# returns: 0: yes, 1: no
#
# Functions boolean question. This function is intended for module
#programmers.
# NOTE: During parsing of arguments of @pwiz_ask_yesno, globbing is
#temporarilly turned off. It prevents accidental expansion of
#"tag[number]=*", especially in nullglob mode.
alias pwiz_ask_yesno="set -o noglob ; pwiz_ask_yesno_f"
function pwiz_ask_yesno_f {
    set +o noglob
    local desc="$1"
    local longdesc="$2"
    shift 2
    pwiz_ask_core pwiz_question_string "$desc" "$longdesc" yesno=true allow_new=false "$@"
    if $pwiz_answer ; then
	return
    else
	return 1
    fi
}

#@ pwiz_ask_string desc longdesc [ tags ]
# desc: short description of feature
# longdesc: long description of feature
# tags: optional tags
# uses tag callback: callback function for "enter manually" (returns
#$pwiz_answer) (default string)
# uses tag allow_new: if set to false, "enter manually" is disabled
#(default true)
# uses tag askmenu_hook: hook function for adding items to askmenu
#(default is nop)
# uses tag no_default: no preselected default - user have to respond
#(default false)
#
# String prompt. This function is intended for module programmers.
#With tag allow_new=false, it can be used as radio switch.
# NOTE: During parsing of arguments of @pwiz_ask_string, globbing is
#temporarilly turned off. It prevents accidental expansion of
#"tag[number]=*", especially in nullglob mode.
alias pwiz_ask_string="set -o noglob ; pwiz_ask_string_f"
function pwiz_ask_string_f {
    set +o noglob
    pwiz_ask_core pwiz_question_string "$@"
}

alias pwiz_ask_radio="set -o noglob ; pwiz_ask_radio_f"
function pwiz_ask_radio_f {
    echo "*** FIXME: pwiz_ask_radio is obsolete. Use pwiz_ask_string with tag allow_new=false"
    set +o noglob

    local desc="$1"
    local longdesc="$2"
    shift 2
    pwiz_ask_core pwiz_question_string "$desc" "$longdesc" allow_new=false "$@"
}

#@ pwiz_ask_core question_function desc longdesc [ tags ]
# question_function: function from question engine
# desc: short description of feature
# longdesc: long description of feature
# tags: optional tags
# returns $pwiz_answer: question result
# returns ${q tag}: answer is also stored to environment variable
#named as q tag
# uses tag q: question ID
# uses tag importance: answer importance (i. e. whether can pwiz continue with default)
# uses tag default[@@]: predefined defaults
# uses tag c[@@]: credits of predefined defaults (optional - array can be sparse)
# uses tag string[@@]: string value for predefined defaults (optional - array can be sparse)
# uses tag hotkey[@@]: guess hotkey for predefined defaults (optional - array can be sparse)
# uses tag valid: validity range (see @pwiz_cache_validity_{name}) (default=exact)
# uses tag yesno: tag for boolean questions (default false)
# uses tag callback: callback function for "enter manually" (returns
#$pwiz_answer) (default string)
# uses tag allow_new: if set to false, "enter manually" is disabled
#(default true)
# uses tag askmenu_hook: hook function for adding items to askmenu
#(default is nop)
# uses tag no_default: no preselected default - user have to respond
#(default false)
# uses tags knowledge: knowledge type required for answer (default
#general)
# uses tag guesslevel: guess level of user's answer (default ask user)
#
# Internal core function for making a guess and asking user. Used by
#@pwiz_ask_{function}. Uses @pwiz_guess.
function pwiz_ask_core {
    local question_function desc longdesc rc count hotkey credit_threshold answer_credit guesslevel knowledge pwiz_answer_save nocred_string nocred_help nocred_no

    # Local variables for use in guess and question engines:
    local -a pwiz_guesses pwiz_credits pwiz_strings pwiz_hotkeys

    question_function=$1
    desc="$2"
    longdesc="$3"
    shift 3
# FIXME: Maybe make one uplevel function common with ask list.
    pwiz_reset_tags
    pwiz_read_tags
    pwiz_keys_set
    pwiz_cache_validity_apply
    local pwiz_cache_key="$pwiz_tag_q/$project/$subproject/$version/$patchlevel/$vendor/$build"

    # Add '*' to pattern for keys, where credit inheritance function exists.
    # This is really needed in pwiz_guess, but it's simpler to set it here.
    for pwiz_key in $pwiz_key_list ; do
	if test "$(type -t "pwiz_guess_credit_$pwiz_key")" = function ; then
	    eval $pwiz_key\=\'\*\'
	fi
    done
    pwiz_cache_validity_apply

    decho_guess "query tags: $*"
    if ! test -z "$pwiz_tag_q" ; then
	eval pwiz_answer\=\"\${$pwiz_tag_q-@@PWIZ_UNDEFINED@@}\"
	if test "$pwiz_answer" != @@PWIZ_UNDEFINED@@ ; then
	    decho_guess "already answered: $pwiz_answer"
	    return
	fi
    fi
    # FIXME: $pwiz_answer_save probably not needed
    pwiz_answer_save="$pwiz_answer"
    knowledge=$pwiz_tag_knowledge
    pwiz_reset_tags
    pwiz_get_knowledge $knowledge
    knowledge=$pwiz_answer
    pwiz_reset_tags
    pwiz_read_tags
    pwiz_answer="$pwiz_answer_save"
    pwiz_guess

    if $pwiz_tag_no_default ; then
	pwiz_guess_best_value=@@PWIZ_UNDEFINED@@
	pwiz_guess_best_credit=-1
	pwiz_guess_best=-1
    fi

    if $OPTARG_CREDIT ; then
	credit_threshold=$OPTVAL_CREDIT
    else
	let credit_threshold=knowledge\*OPTVAL_THRESHOLD/100
	let credit_threshold=credit_threshold\*pwiz_tag_importance/100
    fi
    decho_guess "auto answer threshold credit: $credit_threshold"
    if test $pwiz_guess_best_credit -ge $credit_threshold ; then
	decho_guess "PWIZ auto answer: $pwiz_answer"
	pwiz_question_auto_answer "$desc" "$longdesc" "$pwiz_guess_best"
	pwiz_answer="$pwiz_guess_best_value"
	# We cannot give any credit to automatic answer.
	# FIXME: In multiple-cache source mode, we can copy item from remote cache to local.
	guesslevel=0
    else
	local is_default
	pwiz_askmenu_reset
	if $pwiz_tag_allow_new ; then
	    # FIXME: Implement tag quick_enter (any unknown reply is considered as string for "enter manually").
	    pwiz_askmenu_add pwiz_ask_core_enter_manually "" "enter manually" m "" no_number
	    pwiz_askmenu_add pwiz_ask_core_edit_manually "" "edit manually" 'e{number}' pwiz_preselection_callback_cnumber no_number
	fi
	$pwiz_tag_askmenu_hook

	for (( count=0 ; count < ${#pwiz_guesses[@]} ; count++ )) ; do
	    if test $count = $pwiz_guess_best ; then
		is_default=" is_default"
	    else
		is_default=
	    fi
	    if test -z "${pwiz_strings[count]}" ; then
		pwiz_askmenu_add pwiz_ask_core_askmenu_reply $count "\"${pwiz_guesses[count]}\" (${pwiz_credits[count]}c)" "${pwiz_hotkeys[count]}" "" head$is_default
	    else
		pwiz_askmenu_add pwiz_ask_core_askmenu_reply $count "${pwiz_strings[count]} (${pwiz_credits[count]}c)" "${pwiz_hotkeys[count]}" "" head$is_default
	    fi
	done
	pwiz_askmenu_complete
	pwiz_preselection_callback_cnumber_maxval=$pwiz_askmenu_count

	rc=1
	until test $rc -eq 0 ; do
	    pwiz_fallback_answer=false
	    # Use arguments for question_function, to be able to ask inside ant revert tags.
	    $question_function "$desc" "$longdesc" "$@"
	    pwiz_askmenu_process "$pwiz_answer"
	    rc=$?
	    # FIXME: Unknown selection back-end
#	    if test $rc -gt 1 ; then
#		pwiz_fatal "Unknown selection"
#	    fi
	done

	if ! test -z "$pwiz_tag_q" ; then
	    if test -z "$pwiz_tag_guesslevel" ; then
		pwiz_answer_save="$pwiz_answer"
		pwiz_reset_tags
		pwiz_get_guesslevel
		pwiz_reset_tags
		pwiz_read_tags
		guesslevel=$pwiz_answer
		pwiz_answer="$pwiz_answer_save"
	    else
		guesslevel=$pwiz_tag_guesslevel
	    fi
	fi

    fi

    # FIXME: implement delayed write (write to cache if module confirms or command is successfull).
    # delay=phase will cause writing to cache after getting to phase "phase".
    if ! test -z "$pwiz_tag_q" ; then
# FIXME: remove? maybe needed for "increase patchlevel"
#	# Set again keys (we want value without any *)
#	pwiz_keys_set
#	pwiz_cache_validity_apply
	let answer_credit="knowledge*guesslevel/100"
	decho_guess "going to cache answer \"$pwiz_answer\" to $pwiz_cache_key with credit $answer_credit
(user credit ${knowledge}c, guess level $guesslevel%)"
	# Is this item already in cache?
	if test "$pwiz_cache_key_value" != @@PWIZ_UNDEFINED@@ ; then
	    decho_guess "old cached alswer \"$pwiz_cache_key_value\" with credit $pwiz_cache_key_credit"
	    # Is new answer different from old one?
	    if test "$pwiz_answer" != "$pwiz_cache_key_value" ; then
		nocred_string=
		nocred_help=
		nocred_no=1
		# Are we credible enough to overwrite old value?
		if test $answer_credit -ge $pwiz_cache_key_credit ; then
		    nocred_string="$nocred_string default[$nocred_no]=overwrite string[$nocred_no]=\"overwrite old value\""
		    let nocred_no++
		    nocred_help="$nocred_help Is you select overwrite, it will be impossible to revert previous behavior, if you overwrite old one."
		else
		    nocred_help="$nocred_help Cached answer credit is ${pwiz_cache_key_credit}c. Your answer credit is ${answer_credit}c. Your answer is not credible enough to overwrite old value."
		fi
		# Is there a chance to increase patchlevel?
		if test "$patchlevel" != @ ; then
		    nocred_string="$nocred_string default[$nocred_no]=patchlevel string[$nocred_no]=\"increase patchlevel\""
		    let nocred_no++
		else
		    nocred_help="$nocred_help Increasing of patchlevel is not possible, because this question validity range does not support patchlevel."
		fi
		# FIXME: Add options: ask again for guesslevel or my knowledges
		pwiz_reset_tags
		pwiz_answer_save="$pwiz_answer"
		eval 'pwiz_ask_string "Different answer for last question already exists. What to do now?" \
		    "PWIZ cache already stores the answer for last question: \"$pwiz_cache_key_value\". If your answer will not be cached, it will be lost at the end of current session.$nocred_help" \
		    default[0]=nocache string[0]="do not cache the answer" c[0]=1 \
		    '"$nocred_string allow_new=false knowledge=total guesslevel=100"
		nocred_string="$pwiz_answer"
		pwiz_answer="$pwiz_answer_save"
		pwiz_reset_tags
		pwiz_read_tags
		case $nocred_string in
		    nocache )
			eval $pwiz_tag_q\=\"\$pwiz_answer\"
			return $rc
			;;
		    patchlevel )
			pwiz_patchlevel_set 1
			pwiz_cache_key_value=@@PWIZ_UNDEFINED@@
			pwiz_cache_key_credit=-1
			pwiz_keys_set
			# pwiz_cache_validity_apply is no more needed
			pwiz_cache_key="$pwiz_tag_q/$project/$subproject/$version/$patchlevel/$vendor/$build"
			;;
		    # overwrite ) do nothing, continue
		esac
	    fi
	fi
	if test $answer_credit -ge $pwiz_cache_key_credit ; then
	    pwiz_cache_write "$pwiz_cache_key" "$pwiz_answer" "$@" credit=$answer_credit
	fi
	eval $pwiz_tag_q\=\"\$pwiz_answer\"
    fi
}

#@ pwiz_ask_core_askmenu_reply id answer (internal)
# id: identification of askmenu item from @pwiz_askmenu_add
#(@${pwiz_guesses[@@]})
# answer: user's answer (unused)
# returns: 0
#
# Call question function for enter manually (internal function
#for @pwiz_ask_core).
function pwiz_ask_core_askmenu_reply {
    pwiz_answer="${pwiz_guesses[$1]}"
}

#@ pwiz_ask_core_enter_manually id answer (internal)
# id: identification of askmenu item from @pwiz_askmenu_add (unused)
# answer: user's answer (unused)
# returns $pwiz_answer: user's answer
# returns: 0
#
# Call question function for enter manually (internal function
#for @pwiz_ask_core).
function pwiz_ask_core_enter_manually {
    $pwiz_tag_callback
}

#@ pwiz_ask_core_edit_manually id answer (internal)
# id: identification of askmenu item from @pwiz_askmenu_add
# answer: user's answer
# returns $pwiz_answer: user's answer
# returns: 0: OK, 1: Uses selected numbered item not corresponding to
#guess.
#
# Call question function for enter manually (internal function
#for @pwiz_ask_core).
function pwiz_ask_core_edit_manually {
    local index
    index=${pwiz_askmenu_number_indexes[${2:1}]}
    if test ${pwiz_askmenu_callbacks[index]} != pwiz_ask_core_askmenu_reply ; then
	return 1
    fi
    index=${pwiz_askmenu_ids[index]}
    $pwiz_tag_callback "${pwiz_guesses[index]}"
}

#@ pwiz_patchlevel_set [ incr ]
# incr: patchlevel increment
#
# Set patchlevel. Reads patchlevel from cache and sets it. Must be
#called (done by package module). Can optionally increment patchlevel.
function pwiz_patchlevel_set {
    local plv plc
    plv=${1:-0}
    let plc=99+plv
    pwiz_guess_add pwiz_project_patchlevel $plv $plc
	pwiz_ask_string "Enter patchlevel." \
	    "Now you can specify required patchlevel. This is only a rhetorical question. PWIZ searched in cache and is nearly sure, that it is suggested one." \
	    q=pwiz_project_patchlevel valid=projectstate credit=total guesslevel=100
}

#@ pwiz_knowledge_feature name desc longdesc
# name: name of knowledge type
# desc: short description knowledge type
# longdesc: long description of knowledge type
#
# Knowledge features description. This function is used to add new
#type of knowledge. It can be later used in tag knowledge. The same
#feature can be defined more times.
function pwiz_knowledge_feature {
    eval "pwiz_knowledge_feature_desc_$1="'"$2"'
    eval "pwiz_knowledge_feature_longdesc_$1="'"$3"'
}
pwiz_knowledge_feature general "general packaging" "General knowledge of packaging process without exact specification (this is a default knowledge type)."

#@ pwiz_get_knowledge knowledge_tag
# knowledge_tag: knowledge tag
# returns $pwiz_answer: knowledge value
#
# Internal function to get knowledge credibility for specific
#knowledge type. If required, asks user for response. Special value
#knowledge=total prevents asking user and consider answer as fully
#credible, knowledge=none prevents asking user and consider answer as
#fully incredible.
function pwiz_get_knowledge {
    # FIXME: check for undefined knowledge.
    eval 'local desc="$pwiz_knowledge_feature_desc_'$1'"'
    eval 'local longdesc="$pwiz_knowledge_feature_longdesc_'$1'"'
    pwiz_ask_string "Please qualify your knowledge skills for area \"$desc\"."\
	"$longdesc Defining knowledge skills helps PWIZ to decide, whether to ask you with particular packaging question."\
	q=pwiz_knowledge_$1 valid=setup knowledge=total\
	default[0]=0 string[0]="No knowledges (0c)." c[0]=4\
	default[1]=25 string[1]="Small knowledges (25c)." c[1]=3\
	default[2]=50 string[2]="Average knowledges (50c)." c[2]=2\
	default[3]=75 string[3]="Good knowledges (75c)." c[3]=1\
	default[4]=100 string[4]="Perfect knowledges (100c)." c[4]=0
}
# Special knowledge for questions with total knowledge credit.
# Used internally and for questions with total credibility.
pwiz_knowledge_total=100
# Special knowledge for questions with no knowledge credit.
# Used internally and for questions with total incredibility.
pwiz_knowledge_none=0

#@ pwiz_get_guesslevel
# returns $pwiz_answer: guess level value
#
# Internal function to get guess level for just answered question. If
#required, asks user for response.
function pwiz_get_guesslevel {
    local p0 p25 p50 p75 p100
    if $pwiz_fallback_answer ; then
	if $OPTARG_DEFGUESSLEVEL ; then
	    guesslevel=$OPTVAL_DEFGUESSLEVEL
	    return
	else
	    c0=4 c25=3 c50=2 c75=1 c100=0
	fi
    else
	if $OPTARG_GUESSLEVEL ; then
	    guesslevel=$OPTVAL_GUESSLEVEL
	    return
	else
	    c0=0 c25=4 c50=3 c75=2 c100=1
	fi
    fi
# FIXME: implement and add " or specify guess level in your answer (if it is supported by question engine)"
    pwiz_ask_string "Specify, how sure you are."\
	"You should say, how sure you are with last answer. If you are sure, you will not be asked next time. If you are unsure, next time you will be asked again. If you don't want to see this dialog after each question, use proper command line argument. On the other side, this additional question allows you to press Enter without thinking and giving extra credit to your answer."\
	knowledge=total\
	default[0]=0 string[0]="Random guess. (0%)." c[0]=$c0\
	default[1]=25 string[1]="I'm trying. (25%)." c[1]=$c25\
	default[2]=50 string[2]="Very probably. (50%)." c[2]=$c50\
	default[3]=75 string[3]="Nearly sure. (75%)." c[3]=$c75\
	default[4]=100 string[4]="Absolutely sure. (100%)." c[4]=$c100\
	guesslevel=100
}

#@@ Asking for selection from list

# FIXME: implement pwiz_ask_selection === unordered list

#@ pwiz_ask_list desc longdesc [ tags ]
# desc: short description of feature
# longdesc: long description of feature
# tags: optional tags
# uses tag q: question ID
# uses tag importance: answer importance (i. e. whether can pwiz continue with default)
# uses tag default[@@]: predefined defaults
# uses tag c[@@]: credits of predefined defaults (optional - array can be sparse)
# returns ${pwiz_list_all[@@]}: string with list of available items
#(used by backend (in form ${q}_${list_item})
# returns ${pwiz_list_c_{tag q}[@@]}: credits of selectable items in
#variables (optional - array can be sparse)
# returns ${pwiz_list_string_{tag q}[@@]}: strings value of selectable
#items in variables (optional - array can be sparse)
# returns ${pwiz_list_c_{tag q}[@@]}: guess hotkey of selectable items
#in variables (optional - array can be sparse)
# returns $pwiz_answer: question result
# uses ${pwiz_list_item_{tag q}[@@]}: predefined selectable items in
#variables
# uses ${pwiz_list_item_c_{tag q}[@@]}: credits of selectable items in
#variables (optional - array can be sparse)
# uses ${pwiz_list_item_string_{tag q}[@@}]: string value for
#selectable items in variables (optional - array can be sparse)
# uses ${pwiz_list_item_hotkey_{tag q}[@@]}: guess hotkey for
#selectable items in variables (optional - array can be sparse)
# uses tag item[@@]: available selectable items
#
# Function for asking user for unordered selection from list. This
#function is intended for module programmers.
# For more available variables and tags see @pwiz_ask_core.
# NOTE: During parsing of arguments of @pwiz_ask_list, globbing is
#temporarilly turned off. It prevents accidental expansion of
#"tag[number]=*", especially in nullglob mode.
# NOTE: defaults different from best guess are ignored. There can be
#only one default preset is available.

# FIXME: Maybe {key}_{tag} can be reduced to {tag} while calling subsequent questions
# FIXME: Tag default is not implemented
# FIXME: Implement text representation support
# FIXME: Implement block tag (if block tag is in best guess, item will not be included in pwiz_list_all).
# FIXME: Implement presets.
# FIXME: implement list in list feature (when any item list is ask list).
# It requires cache renaming:
# mylist1 + mylist1_item_1 + mylist_item_2 + mylist_item_2_sub_item_1 => problem
# mylist1 + mylist1__item_1 + mylist__item_2 + mylist__item_2__subitem1 - cut the second @.
# FIXME: Maybe result should have space before and after it (before parsing).
# FIXME: Implement ordered list with repeating and unordered list (set)
alias pwiz_ask_list="set -o noglob ; pwiz_ask_list_f"
function pwiz_ask_list_f {
    set +o noglob

    local desc longdesc key

    desc="$1"
    longdesc="$2"
    shift 2
    pwiz_reset_tags
    pwiz_read_tags
    pwiz_keys_set
    # Add '*' to pattern for keys, where credit inheritance function exists.
    # This is really needed in pwiz_guess, but it's simpler to set it here.
    for pwiz_key in $pwiz_key_list ; do
	if test "$(type -t "pwiz_guess_credit_$pwiz_key")" = function ; then
	    eval $pwiz_key\=\'\*\'
	fi
    done
    pwiz_cache_validity_apply

# FIXME: Is it still true? Probably not.
    if test -z "$pwiz_tag_q" ; then
	pwiz_fatal "pwiz_ask_list must contain tag q"
    fi

    local -a pwiz_list_all pwiz_list_c pwiz_list_strings pwiz_list_hotkeys v_item v_c v_string v_hotkey

#    if ! test -z "$pwiz_tag_q" ; then

	# parse items in environment variables pwiz_list_item_{q} pwiz_list_c_{q} pwiz_list_string_{q} pwiz_list_hotkey_{q}
	# WARNING: Those quesses does not recomputed p
	eval v_total\=\${#pwiz_list_item_$pwiz_tag_q\[@\]}
	for (( count=0 ; count < v_total ; count++ )) ; do
	    eval v_item\=\"\${pwiz_list_item_$pwiz_tag_q\[count\]}\"
	    eval v_c\=\${pwiz_list_item_c_$pwiz_tag_q\[count\]}
	    eval v_string\=\"\${pwiz_list_item_string_$pwiz_tag_q\[count\]}\"
	    eval v_hotkey\=\"\${pwiz_list_item_hotkey_$pwiz_tag_q\[count\]}\"
	    decho_guess "list item in variable: $v_item"
	    pwiz_list_eval "$v_item" "$v_c" "$v_p" "$v_string" "$v_hotkey"
	done

	# callback of pwiz_list_callback_{q}[*]
	eval 'for callback in ${pwiz_list_callback_'"$pwiz_tag_q"'[@]} ; do
	    $callback
	done'

#    fi

    # parse items in tags
    for (( count=0 ; count < ${#pwiz_tag_item[@]} ; count++ )) ; do
	decho_guess "list item in tags: ${pwiz_tag_item[count]}"
# FIXME: read itemstring tag...
	pwiz_list_eval "${pwiz_tag_item[count]}" 0
    done

    # parse items in cache
    decho_guess "list query: $pwiz_tag_q/$project/$subproject/$version/$patchlevel/$vendor/$build"
    pwiz_cache_list "${pwiz_tag_q}_*/$project/$subproject/$version/$patchlevel/$vendor/$build"
    for key_found in $pwiz_result ; do
        pwiz_key_parse $key_found
	eval 'key="${pwiz_item_q#'$pwiz_tag_q'_}"'
	decho_guess "list key in cache: $key"
# FIXME: try to read string tag
	pwiz_list_eval "$key" 0
    done
    pwiz_ask_core pwiz_question_list "$desc" "$longdesc" "$@"

# FIXME: Return usable result in array.
}

#@ pwiz_list_eval item credit string hotkey
# item: list item
# credit: credit of guess (can be empty string)
# string: string value for guess (can be empty string)
# hotkey: guess hotkey (can be empty string)
#
# This internal function evaluates list item and optionally adds it to
#list item array. Used by @pwiz_ask_list.

# FIXME: pwiz_list_p has not yet any meaning.
function pwiz_list_eval {
    local count
    local size=${#pwiz_list_all[@]}
    local is_new=true
    for (( count=0 ; count < size ; count++ )) ; do
	if test "${pwiz_list_all[count]}" = "$1" ; then
	    # If current credit is higher than previous, use current one.
	    # If guess does not provide credit, assume 0.
	    if test ${2:-0} -gt ${pwiz_list_c[count]} ; then
		pwiz_list_c[count]=${2:-0}
	    fi
	    is_new=false
	    break
	fi
    done
# FIXME: Maybe test -z is not required.
    if $is_new ; then
	pwiz_list_c[size]=${2:-0}
	if ! test -z "$3" ; then
	    pwiz_list_strings[size]="$3"
	fi
	if ! test -z "$4" ; then
	    pwiz_list_hotkeys[size]="$4"
	fi
	pwiz_array_add pwiz_list_all "$1"
    else
	if test -z "${pwiz_list_strings[count]}" -a ! -z "$3" ; then
	    pwiz_list_strings[count]="$3"
	fi
	if test -z "${pwiz_list_hotkeys[count]}" -a ! -z "$4" ; then
	    pwiz_list_hotkeys[count]="$4"
	fi
    fi
}

#@ pwiz_list_add id item credit string hotkey
# id: list question ID (corresponds to tag q)
# credit: credit of item (can be empty string)
# string: string value for item (can be empty string)
# hotkey: item hotkey (can be empty string)
#
# Add predefined list item to environment variables
#${pwiz_list_item_{q}}, ${pwiz_list_item_c_{q}},
#${pwiz_list_item_p_{q}}, ${pwiz_list_item_string_{q}} and
#${pwiz_list_item_string_{q}}. Later @pwiz_ask_list can take it in
#account and offer it to user.
# NOTE: Credit is considered as absolute. No user credibility is
#evaluated.

# FIXME: p has not yet any meaning.
function pwiz_list_add {
    eval local count\=\${#pwiz_list_item_$1\[@\]}
    eval pwiz_list_item_$1\[count\]\=\"\$2\"
    eval pwiz_list_item_c_$1\[count\]\=\"\$3\"
    if ! test -z "$4" ; then
	eval pwiz_list_item_string_$1\[count\]\=\"\$4\"
    fi
    if ! test -z "$5" ; then
	eval pwiz_list_item_hotkey_$1\[count\]\=\"\$5\"
    fi
}

#@ {callback} [ tags ]
# tags: optional tags
# returns $pwiz_answer: result of question
#
# Callback function, which is called, if tag callback is set.


#@@@ Phase engine: stages, phases, steps

#@ pwiz_phase_new phase_id { "after" | "before" } existing_phase [ "ok" ]
# phase_id: id of new phase
# { "after" | "before" } existing_phase: position of phase
# "ok": return ok, if phase already exists
#
# Adds new phase to phase engine. You have to specify, after or before
#which phase to add new one. If phase already exists, PWIZ aborts,
#unless 4th arguments is "ok".
function pwiz_phase_new {
    local tmp_phase
    eval tmp_phase\=\$PWIZ_PHASE_AFTER_$3
    if test "$tmp_phase" = "" ; then
	pwiz_fatal "cannot create new phase $1 $2 $3 - $3 is unknown"
    fi
    eval tmp_phase\=\$PWIZ_PHASE_AFTER_$1
    if test "$tmp_phase" = "" ;	then
	case "$2" in
	    after )
		eval tmp_phase\=\$PWIZ_PHASE_AFTER_$3
		eval PWIZ_PHASE_AFTER_$3\=$1
		eval PWIZ_PHASE_BEFORE_$1\=$3
		eval PWIZ_PHASE_AFTER_$1\=$tmp_phase
		eval PWIZ_PHASE_BEFORE_$tmp_phase\=$1
		;;
	    before )
		eval tmp_phase\=\$PWIZ_PHASE_BEFORE_$3
		eval PWIZ_PHASE_AFTER_$tmp_phase\=$1
		eval PWIZ_PHASE_BEFORE_$1\=$tmp_phase
		eval PWIZ_PHASE_AFTER_$1\=$3
		eval PWIZ_PHASE_BEFORE_$3\=$1
		;;
	    * )
		pwiz_fatal "bad specification of phase insertion type"
	esac
	eval declare -a PWIZ_STAGE_$1
	eval declare -a PWIZ_STAGE_EVAL_$1
    else
	if test "$3" != "ok" ; then
	    pwiz_fatal "phase $1 already exists"
	fi
    fi
}
PWIZ_PHASE_AFTER_BEGIN=END
PWIZ_PHASE_BEFORE_END=BEGIN

#@ pwiz_phase_list
# returns: lists all existing phases (FIXME will change to
#$pwiz_result in future versions)
#
# List of all existing phases.

# FIXME: return output to $pwiz_result.
function pwiz_phase_list {
    eval local phase\=\$PWIZ_PHASE_AFTER_BEGIN
    while [ $phase != END ] ; do
	echo $phase
	eval phase\=\$PWIZ_PHASE_AFTER_$phase
    done
}

#@ pwiz_phase_add phase contents
# phase: existing phase
# contents: contents of action to be added
#
# Adds an action as a last action of a phase.
# NOTE: If your command needs quotes and special characters, you have
#to escape them to prevent double bash expansion.

# FIXME: undo actions
function pwiz_phase_add {
# FIXME: for debugging only:
    if test "$3" != "" ; then
	pwiz_fatal "3 arguments: pwiz_phase_add $*"
    fi
    local tmp_phase
    eval tmp_phase\=\$PWIZ_PHASE_AFTER_$1
    if test "$tmp_phase" = "" ; then
	pwiz_fatal "cannot add to phase $1 - phase does not exist"
    fi
    pwiz_array_add PWIZ_STAGE_$1 "$2"
}

#@ pwiz_phase_add_callme phase [ arg ]
# phase: existing phase
# arg: argument to function
#
# Add call to function module_phase with arguments arg to phase to be
#used in module initialization.
# It is the simplification of:
#@<
#pwiz_phase_add {phase} "{module}_{phase} {arg}"
#@>
# NOTE: If your arguments needs quotes and special characters, you
#have to escape them to prevent double bash expansion.
# WARNING: This function cannot be called outside module init.

# FIXME with pwiz_module_exec: In future, argumentless version will call function named as module
# FIXME: undo actions
function pwiz_phase_add_callme {
# FIXME: for debugging only:
    if test "$3" != "" ; then
	pwiz_fatal "3 arguments: pwiz_phase_add_callme $*"
    fi
    if test "$pwiz_module_current" = "ERROR" ; then
	pwiz_fatal "pwiz_phase_add_callme called outside init"
    fi
    pwiz_phase_add "$1" "${pwiz_module_current}_$1${2:+ $2}"
}

#@ pwiz_phase_new_call phase_id { "after" | "before" } existing_phase [ arg ]
# phase_id: id of new phase
# { "after" | "before" } existing_phase: position of phase
# arg: argument to function
#
# Create new phase and add a call to function module_phase with
#arguments arg to this phase. This function can be used in module
#initialization.
# It is the simplification of:
#@<
#pwiz_phase_new {phase} {after|before} {existing_phase}
#pwiz_phase_add {phase} "{module}_{phase} {arg}"
#@>
# NOTE: If your arguments needs quotes and special characters, you
#have to escape them to prevent double bash expansion.
# WARNING: This function cannot be called outside module init.

# FIXME: undo actions
# FIXME with pwiz_module_exec: In future, argumentless version will call function named as module
function pwiz_phase_new_call {
# FIXME: for debugging only:
    if test "$5" != "" ; then
	pwiz_fatal "5 arguments: pwiz_phase_new_call $*"
    fi
    pwiz_phase_new "$1" "$2" "$3"
    pwiz_phase_add "$1" "$1${4:+ $4}"
}

#@ pwiz_phase_new_3 phase_id { "after" | "before" } existing_phase [ arg ]
# phase_id: id of new phase
# { "after" | "before" } existing_phase: position of phase
# arg: argument to function
#
# Create all needed for three phase structure: set data
#({phase}_prepare), allow user to modify ({phase}) and use data
#({phase}_set). This structure is widely used by PWIZ to allow
#modification of any decission by third party modules. It also defines
#function {phase}_provider, which can be used in third party modules
#(it's equivalent to pwiz_phase_add_callme {phase} - without {arg})
# It is the simplification of:
#@<
#pwiz_phase_new {phase}_prepare {after|before} {existing_phase}
#pwiz_phase_new {phase} after {phase}_prepare
#pwiz_phase_new {phase}_set after {phase}
#pwiz_phase_add {phase}_prepare "{module}_{phase}_prepare {arg}"
#pwiz_phase_add {phase}_set "{module}_{phase}_set {arg}"
#function {phase}_provider {
#    pwiz_phase_add_callme {phase}
#}
#@>
# NOTE: If your arguments needs quotes and special characters, you
#have to escape them to prevent double bash expansion.
# WARNING: Optional argument {arg} is not used in {phase}_provider.
# WARNING: This function cannot be called outside module init.

#@ {phase}_provider
#
# Function created by @pwiz_phase_new_3.
# It's equivalent of:
#@<
#pwiz_phase_add_callme {module}
#@>
# WARNING: This function cannot be called outside module init.

# FIXME: undo actions
function pwiz_phase_new_3 {
    pwiz_phase_new_call $1_prepare $2 $3 $4
    pwiz_phase_new $1 after $1_prepare
    pwiz_phase_new_call $1_set after $1 $4
    eval "function $1_provider {
    pwiz_phase_add_callme $1
}"
}

#@ pwiz_phase_new_3_guess phase_id { "after" | "before" } existing_phase [ arg ]
# phase_id: id of new phase
# { "after" | "before" } existing_phase: position of phase
# arg: argument to function
#
# Create all needed for three phase structure (it does everything,
#what @pwiz_phase_new_3 does) and create function {phase}_guess to
#register new guess for question with q={phase} (see @{phase}_guess).
# It is the simplification of:
#@<
#pwiz_phase_new_3 {phase} {after|before} {existing_phase} {arg}
#function $1_guess {
#    pwiz_guess_add {phase} "$@"
#}
#@>
# NOTE: If your arguments needs quotes and special characters, you
#have to escape them to prevent double bash expansion.
# WARNING: This function cannot be called outside module init.

#@ {phase}_guess guess credit string hotkey
# guess: value of guess
# credit: credit of guess (can be empty string)
# string: string value for guess (can be empty string)
# hotkey: guess hotkey (can be empty string)
#
# Guess function, as created by @pwiz_phase_new_3 (see @pwiz_guess_add
#for more).

# FIXME: undo actions
function pwiz_phase_new_3_guess {
#    pwiz_phase_new $1_prepare $2 $3
    pwiz_phase_new_call $1_prepare $2 $3 $5
#    pwiz_phase_add $1_prepare "$1_guesses_count=0 $1_guesses="
#    pwiz_phase_add_callme $1_prepare
    pwiz_phase_new $1 after $1_prepare
    pwiz_phase_new_call $1_set after $1 $5
    eval "function $1_provider {
    pwiz_phase_add_callme $1
}"
    eval "function $1_guess {
    pwiz_guess_add $1 \"\$@\"
}"
}

#@ pwiz_phase_add_run phase contents
# phase: existing phase
# contents: contents of action to be added for execution
#
# Adds protected run command (see also @pwiz_phase_add).
# Equivalent of:
#@<
#pwiz_phase_add phase "pwiz_run contents"
#@>
# NOTE: Commands beginning by "pwiz_run" are evaluated in phase engine
#in a special way preventing double expansion.
function pwiz_phase_add_run {
# FIXME: for debugging only:
    if test "$3" != "" ; then
	pwiz_fatal "3 arguments: pwiz_phase_add_run $*"
    fi
    pwiz_phase_add "$1" "pwiz_run $2"
}

# pwiz_phase_add_run_eval phase contents
# similar to pwiz_phase_add_run phase pwiz_run eval contents
# Adds protected run command with shell evaluation in time of call.
# WARNING: Remember not to expand variables, i. e. use single quotes or backslashes.
function pwiz_phase_add_run_eval {
# FIXME: for debugging only:
    pwiz_warning "deprecated: pwiz_phase_add_run_eval $*"
    if test "$3" != "" ; then
	pwiz_fatal "3 arguments: pwiz_phase_add_run_eval $*"
    fi
    pwiz_phase_add "$1" "pwiz_run_eval $2"
}


#@ pwiz_phase_add_rem phase contents
# phase: existing phase
# contents: contents of action to be inserted
#
# Adds a comment to protected command list (see also @pwiz_phase_add).
# Equivalent of:
#@<
#pwiz_phase_add phase "pwiz_rem contents"
#@>
# NOTE: Commands beginning by "pwiz_rem" are evaluated in phase engine
#in a special way preventing line splittion. You can add multiple
#lines using single command using pwiz_phase_add_rem.
function pwiz_phase_add_rem {
# FIXME: for debugging only:
    if test "$3" != "" ; then
	pwiz_fatal "3 arguments: pwiz_phase_add_rem $*"
    fi
    pwiz_phase_add "$1" "pwiz_rem $2"
}

# FIXME: deprecated
#function pwiz_phase_add_rem_eval {
#    if test "$3" != "" ; then
#	pwiz_fatal "3 arguments: pwiz_phase_add_rem_eval $*"
#    fi
#    pwiz_phase_add "$1" "pwiz_rem_eval $2"
#}

# FIXME: semms to be unused. Remove.
# pwiz_phase_check phase arguments
# Special command for init
#function pwiz_phase_check {
#    pwiz_array_add PWIZ_STAGE_$1 "$pwiz_module_current $2"
#}
# pwiz_phase_clean phase
#function pwiz_phase_clean {
#    eval unset PWIZ_STAGE_$1
#    eval declare -a PWIZ_STAGE_$1
#}

#@ pwiz_stage_next
# returns: 0: OK, 1: no next stage
#
# Go to next stage.
function pwiz_stage_next {
    local pwiz_step_phase_stages
    eval pwiz_step_phase_stages=\${#PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[\*\]}
    let PWIZ_STAGE_CURRENT++
    if test $PWIZ_STAGE_CURRENT -ge $pwiz_step_phase_stages ; then
	return 1
    else
	return 0
    fi
}

#@ pwiz_stage_prev
# returns: 0: OK, 1: no previous stage
#
# Go to previous stage.
function pwiz_stage_prev {
    local pwiz_step_phase_stages
    eval pwiz_step_phase_stages=\${#PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[\*\]}
    let PWIZ_STAGE_CURRENT--
    if test $PWIZ_STAGE_CURRENT -ge $pwiz_step_phase_stages -o $PWIZ_STAGE_CURRENT -lt -1 ; then
	return 1
    else
	return 0
    fi
}

#@ pwiz_stage_goto stage
# stage: stage number
# returns: 0: OK, 1: no such stage
#
# Goto any stage.

# FIXME: must run through undo actions
function pwiz_stage_goto {
    local pwiz_step_phase_stages
    eval pwiz_step_phase_stages=\${#PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[\*\]}
    PWIZ_STAGE_CURRENT=$1
    if test $PWIZ_STAGE_CURRENT -lt -1 ; then
	return 1
    else
	return 0
    fi
}


#@ pwiz_phase_next
# returns: 0: OK, 1: no next phase
#
# Go to next phase.
function pwiz_phase_next {
    local pwiz_step_phase_stages
    while : ; do
	eval PWIZ_PHASE_CURRENT\=\$PWIZ_PHASE_AFTER_$PWIZ_PHASE_CURRENT
	if [ $PWIZ_PHASE_CURRENT = END ] ; then
	    return 1
	fi
	eval pwiz_step_phase_stages=\${#PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[\*\]}
	if test $pwiz_step_phase_stages -eq 0 ; then
	    vvecho "Skipping empty phase $PWIZ_PHASE_CURRENT..."
	else
	    break
	fi
    done
    PWIZ_STAGE_CURRENT=-1
    vecho "Entering phase $PWIZ_PHASE_CURRENT..." >&2
}

#@ pwiz_phase_prev
# returns: 0: OK, 1: no previous phase
#
# Go to previous phase.
# WARNING: sets stage counter to first stage of phase, not last!
# WARNING: If previous phase is empty, it skips back to current. It is
#not reverse function to pwiz_phase_next.
function pwiz_phase_prev {
    local pwiz_step_phase_stages
    eval PWIZ_PHASE_CURRENT\=\$PWIZ_PHASE_BEFORE_$PWIZ_PHASE_CURRENT
    if [ $PWIZ_PHASE_CURRENT = BEGIN ] ; then
	return 1
    fi
    eval pwiz_step_phase_stages=\${#PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[\*\]}
    if test $pwiz_step_phase_stages -eq 0 ; then
	pwiz_phase_next
    else
	PWIZ_STAGE_CURRENT=-1
	vecho "Entering phase $PWIZ_PHASE_CURRENT..." >&2
    fi
}

#@ pwiz_phase_goto phase
# phase: phase name
# returns: 0: OK, 1: no such phase
#
# Goto any phase.
# WARNING: sets stage counter to first stage, not last!
# WARNING: If phase is empty, it skips forward.
function pwiz_phase_goto {
    local pwiz_step_phase_stages pwiz_phase_save
    pwiz_phase_save=$PWIZ_PHASE_CURRENT
    eval PWIZ_PHASE_CURRENT\=\$PWIZ_PHASE_BEFORE_$1
    if test -z "$PWIZ_PHASE_CURRENT" ; then
	PWIZ_PHASE_CURRENT=$pwiz_phase_save
	return 1
    fi
    PWIZ_PHASE_CURRENT=$1
    PWIZ_STAGE_CURRENT=-1
    eval pwiz_step_phase_stages=\${#PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[\*\]}
    if test $pwiz_step_phase_stages -eq 0 ; then
	pwiz_phase_next
    else
	vecho "Entering phase $PWIZ_PHASE_CURRENT..." >&2
    fi
}

#@ pwiz_next
# returns: 0: OK, 1: no next stage and phase
#
# Goto next action in phase engine. Error means, that END was reached.
function pwiz_next {
    if ! pwiz_stage_next ; then
	if pwiz_phase_next ; then
	    PWIZ_STAGE_CURRENT=0
	else
	    return 1
	fi
    fi
}

#@ pwiz_step action { "query" | "run" }
# returns: 0: phase and stage exists and executed, 1: no next stage
#and phase
# "query": query action, not execute
# returns $pwiz_result: in query mode, stage action is returned in
#this variable
# "run": execute action
# returns $pwiz_rc: in run mode, it contains result code of command
#(if any)
#
# Standard step of phase engine.
# NOTE: pwiz_step first increments counters, then executes, to enable
#roll-ons (commands adding action immediatelly after current stage).
# WARNING: Return code is not return code of executed stage!
function pwiz_step {
    local pwiz_step_stage_code rc
    if pwiz_next ; then
	vvecho "Entering stage $PWIZ_PHASE_CURRENT[$PWIZ_STAGE_CURRENT]..." >&2
	eval pwiz_step_stage_code=\"\${PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[$PWIZ_STAGE_CURRENT\]}\"
	case $1 in
	    query )
		pwiz_result="$pwiz_step_stage_code"
		;;
	    run )
# FIXME pwiz_rem and pwiz_rem_eval
		vvecho -e "Running: $pwiz_step_stage_code"
# FIXME: pwiz_rune does not need this expansion, but direct run yes
# Do it better, this is a hack.
		if $OPTARG_PROMPT ; then
		    pwiz_prompt +
		fi
		if test "${pwiz_step_stage_code%% *}" = pwiz_run ; then
		    pwiz_run "${pwiz_step_stage_code#pwiz_run }"
		else
		    if ! test "${pwiz_step_stage_code%% *}" = pwiz_rem ; then
			eval "$pwiz_step_stage_code"
		    fi
		fi
		pwiz_rc=$?
		if $OPTARG_PROMPT ; then
		    pwiz_prompt -
		fi
		;;
	esac
	return 0
    else
	return 1
    fi
}

#@ pwiz_phase_reset
#
# Reset phase engine (go to phase BEGIN, stage 0). Needed for
#switching between query and run mode (see @pwiz_step).
function pwiz_phase_reset {
    PWIZ_PHASE_CURRENT=BEGIN
    PWIZ_STAGE_CURRENT=0
}
pwiz_phase_reset

#@ pwiz_phase_save
#
# Save phase engine status. Needed for switching between query and run
#mode (see @pwiz_step).
function pwiz_phase_save {
    PWIZ_PHASE_CURRENT_save=$PWIZ_PHASE_CURRENT
    PWIZ_STAGE_CURRENT_save=$PWIZ_STAGE_CURRENT
}

#@ pwiz_phase_restore
#
# Restore phase engine status. Needed for switching between query and
#run mode (see @pwiz_step).
function pwiz_phase_restore {
    PWIZ_PHASE_CURRENT=$PWIZ_PHASE_CURRENT_save
    PWIZ_STAGE_CURRENT=$PWIZ_STAGE_CURRENT_save
    unset PWIZ_PHASE_CURRENT_save PWIZ_STAGE_CURRENT_save
}


#@@@ Manipulation with modules
# Module is a piece of bash code, sourced from PWIZ core.
# It typically implements package checks, expert system knowledges and its infrastructure.

#@ {module_name}.pwm [ command ]
# command: Command for module.
#
# Run module with command.
# Available commands:
# @desc: show description and return
# @longdesc: show long description and return
# @init: initialize engine (during initialization, variable
#$pwiz_module_current is available)
# @version: show module version

#@ $pwiz_module_current
# This variable is defined during module initialization (see @{module_name}.pwm).

# FIXME: Check - module must not contain "-" and similar characters (only alphanum and @).

#@ pwiz_modules_list
#
# returns: list of engines to stdout (FIXME will change to
#$pwiz_result in future versions)
#
# List all available modules.

function pwiz_modules_list {
    local file
    (
	cd @PW_DATADIR@/modules
# FIXME: Use pwiz_result instead of redirection
	for file in *.pwm ; do
	    echo ${file%.pwm}
	done
    )
}

#@ pwiz_modules_load
#
# Load all available modules (internal function).
function pwiz_modules_load {
    local file
	for file in $(pwiz_modules_list) ; do
	    if test $OPTCNT_VERBOSE -ge 1 ; then
		if test $OPTCNT_VERBOSE -ge 2 ; then
		    echo "Loading module $file ($(pwiz_module_desc $file))..."
		    if test $OPTCNT_VERBOSE -ge 3 ; then
			pwiz_module_longdesc $file
		    fi
		else
		    echo "Loading module $file..."
		fi
	    fi
	    pwiz_module_load $file
	done
}

#@ pwiz_module_desc module
# module: name of module
#
# Prints module description.
function pwiz_module_desc {
    . @PW_DATADIR@/modules/$1.pwm desc
}

#@ pwiz_module_longdesc module
# module: name of module
#
# Prints module long description.
function pwiz_module_longdesc {
    . @PW_DATADIR@/modules/$1.pwm longdesc
}

pwiz_module_current="ERROR"

#@ pwiz_module_load module
# module: name of module
#
# Load a module. In normal conditions, there is no need to call this
#functions explicitly, use @pwiz_module_needs instead). It has a
#protection against multiple loading.
function pwiz_module_load {
    local loaded pwiz_module_current_save
    eval loaded\=\"\$PWIZ_MODULE_LOADED_$1\"
    if test -z "$loaded" ; then
	pwiz_module_source $1 init
	eval PWIZ_MODULE_LOADED_$1\=1
    fi
}

#@ pwiz_module_source module
# module: name of module
#
# Immediatelly load a module. Internal function, used
#by @pwiz_module_load).
function pwiz_module_source {
    local pwiz_module_current_save
    pwiz_module_current_save="$pwiz_module_current"
    pwiz_module_current=$1
    if ! test -f @PW_DATADIR@/modules/$1.pwm ; then
	pwiz_fatal "module $1 not found"
    fi
    shift
    . @PW_DATADIR@/modules/$pwiz_module_current.pwm "$@"
    pwiz_module_current="$pwiz_module_current_save"
}

#@ pwiz_module_needs module ...
# module: module to be loaded
#
# Loads needed modules. Used by module init.
# NOTE: You need it only for modules required for module init,
#otherwise @pwiz_module_uses is enough.
function pwiz_module_needs {
    local module
    for module in "$@" ; do
	pwiz_module_load "$module"
    done
}

#@ pwiz_module_uses module ...
# module: used module
#
# Checks, whether needed modules are available. Modules itself can be
#loaded later.
# WARNING: Do not use this function for modules needed during
#initialization.

# FIXME: implement it
function pwiz_module_uses {
    :
}

# -----------------------

# FIXME: phases for subpackage testing.

#@@ Phase skeleton
# Phase skeleton is a set of phases available unconditionally in all
#PWIZ instances. There is a list with explanation of expected usage.
# basic phase descriptions:
# BEGIN
#  > special general actions
# START
#  > general actions only, $pwiz_project_* attributes are not defined
# PROJECT
#  > project and version selection process, here you can set
#$pwiz_project_*
# SETUP
#  > set up pwiz for work with known project, access where appropriate
#($PWIZ_TMPSDIR)
# SOURCE
#  > get sources, set extended project attributes, $pwiz_project_* are
#set, access to $PWIZ_SOURCESDIR
# PREPARE
#  > prepare source code (unpack, patch), access to $PWIZ_SRCDIR
#    subphases: PREPARE_CLEAN PREPARE_PREUNPACK PREPARE_UNPACK
#PREPARE_POSTUNPACK PREPARE_CHECK PREPARE_PATCH PREPARE_RECHECK
# BUILD
#  > build project (configure, compile), access to $PWIZ_BUILDDIR
#    subphases: BUILD_SETENV BUILD_CONF BUILD_POSTCONFHACK
#BUILD_PRECOMPILE BUILD_COMPILE BUILD_POSTCOMPILE
# PREINSTALL
#  > special actions before installation to install root, keep empty
#if possible
#    WARNING: use premerge for standard pre-installation processes
# INSTALL
#  > install project, access to $PWIZ_INSTALLROOT
#    subphases: INSTALL_PREPARE INSTALL_PREACTION INSTALL_ACTION
#INSTALL_POSTACTION INSTALL_CHECK INSTALL_POSTCHECK
# CHECKINSTALL
#  > Check all installed things. Read access.
# PREMERGE
#  > actions before install, access to live system only special
#actions
# MERGE
#  > merge project for live system, access to live system
# CLEAN
#  > clean project buld environment, access to all temporary dirs
# POSTINSTALL
#  > post installation actions, access to live system
# RUNTEST
#  > tests for instaled package, access to live system
# PREUNINSTALL
#  > special actions before package uninstallation
# UNMERGE
#  > perform uninstallation, access to live system
# POSTUNINSTALL
#  > special actions after package uninstallation, access to live
#system
# RESULTS
#  > very last actions, access to $PWIZ_RESULTDIR
# FINISH
#  > very last actions, access nowhere
# END
# Each phase has counterpair {phase}_LAST for simple and portable adding to the end of actions.
#
# NOTE: Recommendation for custom phases: Use lowecase. Take these ones as "constants".
# NOTE: If your action surely does not need any action before it in the
#same range, you can use listed phases, otherwise create own phase.
# WARNING: For listed major phases, avoid if possible: pwiz_phase_add before PHASE
# WARNING: For listed major phases, avoid if possible: pwiz_phase_add after PHASE_LAST

#FIXME: rename phase SETUP???

#@ init_phase_skeleton
#
# Creates phases in skeleton (internal function).
function init_phase_skeleton {
    local phase prev_phase
    prev_phase=BEGIN
    for phase in START PROJECT SETUP SOURCE\
	PREPARE PREPARE_CLEAN PREPARE_PREUNPACK PREPARE_UNPACK PREPARE_POSTUNPACK PREPARE_CHECK PREPARE_PATCH PREPARE_RECHECK\
	BUILD BUILD_SETENV BUILD_CONF BUILD_POSTCONFHACK BUILD_PRECOMPILE BUILD_COMPILE BUILD_POSTCOMPILE\
	PREINSTALL\
	INSTALL INSTALL_PREPARE INSTALL_PREACTION INSTALL_ACTION INSTALL_POSTACTION INSTALL_CHECK INSTALL_POSTCHECK\
	CHECKINSTALL PREMERGE MERGE CLEAN POSTINSTALL RUNTEST PREUNINSTALL UNINSTALL POSTUNINSTALL RESULTS FINISH ; do
	pwiz_phase_new $phase after $prev_phase
	pwiz_phase_new ${phase}_LAST after $phase
	prev_phase=${phase}_LAST
    done
}


#  FIXME: In conf file.
engine_cache=file
engine_question=dumb
# FIXME: Default should be none
engine_pkgdb=rpm

if $OPTARG_LIST_MODULES ; then
    PWIZ_VERBOSE_COUNT=0
else
    vecho -e "\nInitializing PWIZ..."
    PWIZ_VERBOSE_COUNT=1
fi

if test $OPTCNT_VERBOSE -ge $PWIZ_VERBOSE_COUNT ; then
	eecho
	eecho "Engines..."
fi
for pwiz_file in cache question pkgdb ; do
    if test $OPTCNT_VERBOSE -ge $((PWIZ_VERBOSE_COUNT+2)) ; then
	eecho
    fi
    if test $OPTCNT_VERBOSE -ge $PWIZ_VERBOSE_COUNT ; then
	if $OPTARG_LIST_MODULES ; then
	    eecho -n "Engine"
	else
	    eecho -n "Loading engine"
	fi
	eval "eecho -n \" $pwiz_file: \$engine_$pwiz_file\""
	if test $OPTCNT_VERBOSE -ge $((PWIZ_VERBOSE_COUNT+1)) ; then
	    eval "eecho -n \" (\$(pwiz_engine_desc $pwiz_file \${engine_$pwiz_file:-\$engine_$pwiz_file}))\""
	fi
	eecho "..."
    fi
    if test $OPTCNT_VERBOSE -ge $((PWIZ_VERBOSE_COUNT+2)) ; then
	eval "pwiz_engine_longdesc $pwiz_file \${engine_$pwiz_file:-\$engine_$pwiz_file}"
    fi
    if ! $OPTARG_LIST_MODULES ; then
	eval "pwiz_engine_load $pwiz_file \${engine_$pwiz_file:-\$engine_$pwiz_file}"
    fi
done

if test $OPTCNT_VERBOSE -ge $PWIZ_VERBOSE_COUNT ; then
    eecho
    eecho "Modules..."
fi
if $OPTARG_LIST_MODULES ; then
    for pwiz_file in $(pwiz_modules_list) ; do
	if test $OPTCNT_VERBOSE -ge 2 ; then
	    eecho
	fi
	eecho -n "Module: $pwiz_file"
	if test $OPTCNT_VERBOSE -ge 1 ; then
	    eecho -n " ($(pwiz_module_desc $pwiz_file))"
	fi
	eecho "..."
	if test $OPTCNT_VERBOSE -ge 2 ; then
	    pwiz_module_longdesc $pwiz_file
	fi
    done
    eecho
    exit
fi

# Maybe FIXME:
unset debug_option engine_cache engine_question engine_pkgdb pwiz_file PWIZ_VERBOSE_COUNT

init_phase_skeleton

pwiz_modules_load

# FIXME: feature list and all
# FIXME: Report unknown features.
# Debug messages (cannot appear in module init phase).
IFS="${IFS}:,"
pwiz_debug_list=false
for pwiz_debug_feature in ${pwiz_debug_features[@]} ; do
    pwiz_feature_active=false
    for pwiz_debug_option in $OPTVAL_DEBUG ; do
	if test "$pwiz_debug_option" = list ; then
	    pwiz_debug_list=true
	else
	    if test "$pwiz_debug_option" = "$pwiz_debug_feature" -o  "$pwiz_debug_option" = all ; then
		pwiz_feature_active=true
	    fi
	fi
    done
    if $pwiz_feature_active ; then
	eval pwiz_debug_$pwiz_debug_feature\=true
	eval "function decho_$pwiz_debug_feature {
    echo >&2 \"\$@\"
}"
    else
	eval pwiz_debug_$pwiz_debug_feature\=false
	eval "function decho_$pwiz_debug_feature {
    :
}"
    fi
done
IFS=${IFS%??}


if $pwiz_debug_list ; then
    PWIZ_VERBOSE_COUNT=0
else
    PWIZ_VERBOSE_COUNT=1
fi

if test $OPTCNT_VERBOSE -ge $PWIZ_VERBOSE_COUNT ; then
	eecho
	eecho "Debug features..."
fi
pwiz_debug_on="on"
pwiz_debug_off="off"
for pwiz_debug_feature in ${pwiz_debug_features[@]} ; do
    if test $OPTCNT_VERBOSE -ge $((PWIZ_VERBOSE_COUNT+2)) ; then
	eecho
    fi
    if test $OPTCNT_VERBOSE -ge $PWIZ_VERBOSE_COUNT ; then
	eecho -n ""
	eval "eecho -n \"Debug feature $pwiz_debug_feature \""
	eval "if \$pwiz_debug_$pwiz_debug_feature ; then eecho -n \"$pwiz_debug_on\" ; else eecho -n \"$pwiz_debug_off\" ; fi"
	if test $OPTCNT_VERBOSE -ge $((PWIZ_VERBOSE_COUNT+1)) ; then
	    eval "eecho -n \" (\$pwiz_debug_desc_$pwiz_debug_feature)\""
	fi
	eecho ""
    fi
    if test $OPTCNT_VERBOSE -ge $((PWIZ_VERBOSE_COUNT+2)) ; then
	eval "eecho \" \$pwiz_debug_longdesc_$pwiz_debug_feature\""
    fi
done
vecho
if $pwiz_debug_list ; then
    exit
fi
unset pwiz_debug_option pwiz_debug_feature pwiz_feature_active PWIZ_VERBOSE_COUNT pwiz_debug_list pwiz_debug_on pwiz_debug_off



pwiz_projectdirs_init

while pwiz_step run ; do
    :
done

pwiz_exit
