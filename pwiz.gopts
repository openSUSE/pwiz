#! /bin/bash

unalias -a
shopt -s expand_aliases
# FIXME: Set it on for debugging purposes. Otherwise strange globbing problems can occur in real life.
shopt -s nullglob

@genopts

@code_style line_up function_keyword casetab

@program pwiz

@version 0.0

@year 2004

@author Stanislav Brabec

@bugsto Stanislav Brabec <sbrabec@suse.cz>

@free_copy

@usage [OPTION]... [FILE]...

@short
Packaging Wizard provides a framework for simplification of packaging process.

@defaults PWIZ_OPTIONS
You can change default behavior by changing many environment variables
(see documentation for PWIZ and modules for more).

@not_yet_implemented_switch FAST -f --fast
Run in fast mode. Runs without break until there is a
question without default guess.

@not_yet_implemented_switch BATCH -b --batch
Run in batch mode. Fails if there is a question without
default guess.

@switch PROMPT -p --prompt
Debug shell prompt before and after each stage.

@switch LIST_MODULES --list-modules
List all modules and exit.

@cntswitch VERBOSE -v --verbose
Increase level of verbosity.

@cntswitch QUIET -q --quiet
Decrease level of verbosity.

@option DEBUG -d --debug=TYPE
Comma separated list of specific debugging messages.
Try --debug=list for all available types.
All turns all debugging messages.

@options_only

@end

#@ Verbose messages.
alias eecho='echo >&2'

if test $OPTCNT_VERBOSE -ge 1 ; then
    alias vecho='echo >&2'
else
    alias vecho=:
fi

if test $OPTCNT_VERBOSE -ge 2 ; then
    alias vvecho='echo >&2'
else
    alias vvecho=:
fi

if test $OPTCNT_VERBOSE -ge 3 ; then
    alias vvvecho='echo >&2'
else
    alias vvvecho=:
fi

#@ Unverbose messages.
if test $OPTCNT_QUIET -ge 1 ; then
    alias qecho=:
else
    alias qecho='echo >&2'
fi

if test $OPTCNT_QUIET -ge 2 ; then
    alias qqecho=:
else
    alias qqecho='echo >&2'
fi

#@ pwiz_debug_feature name desc longdesc
#@ Debug features.
function pwiz_debug_feature {
    pwiz_array_add pwiz_debug_features "$1"
    eval "pwiz_debug_desc_$1="'"$2"'
    eval "pwiz_debug_longdesc_$1="'"$3"'
}
declare -a pwiz_debug_features


# FIXME
trap "echo \"PWIZ must be error-less\" ; exit 1" ERR

# FIXME: declare most functions readonly (declare -f -r or -F -r, readonly -f)
# FIXME: declare integers, where appropriate

# These will be variables in future, not constants.
# FIXME: All those should be queried:
#pwiz_project_project=gnome-panel
#pwiz_project_version_policy=even_subversion_is_stable
pwiz_project_subproject=-
#pwiz_project_version=2.4.0
pwiz_project_patchlevel=0
pwiz_project_vendor=SuSE
pwiz_project_product=Linux
pwiz_project_pversion=9.0
pwiz_project_build=0

# Knowledge defaults.
pwiz_knowledge_general=80
pwiz_knowledge_build=80

#@@ general

#@ Debug prompt
function pwiz_prompt {
    local REPLY
    local HISTFILE=~/.pwiz_history
    echo
    vecho "Shell prompt. Empty line for exit. Mult-line strings are not allowed."
# FIXME: Maybe global and trap
    history -r
# FIXME: Completion
    while read -e -r -p "$1$PWIZ_PHASE_CURRENT[$PWIZ_STAGE_CURRENT]
$pwiz_step_stage_code
pwiz@$PWD> " ; do
	if test -z "$REPLY" ; then
	    break
	fi
	eval "$REPLY"
	let HISTCMD++
	history -s "$REPLY"
# FIXME: Maybe global and trap
	history -a
    done
    echo
}

#@ fast redirection
# channels 5-7 are reserved for saving original redirection

#@ pwiz_redirect_stdin file
function pwiz_redirect_stdin {
    exec 5<&0
    exec <"$1"
}
#@ pwiz_redirect_stdout file
function pwiz_redirect_stdout {
    exec 6>&1
    exec >"$1"
}
#@ pwiz_redirect_stdout file
function pwiz_redirect_stderr {
    exec 7>&2
    exec 2>"$1"
}
#@ pwiz_redirect_stdout_append file
function pwiz_redirect_stdout_append {
    exec 6>&1
    exec >>"$1"
}
#@ pwiz_redirect_stderr_append file
function pwiz_redirect_stderr_append {
    exec 7>&2
    exec 2>>"$1"
}
#@ pwiz_redirect_stdin_close
function pwiz_redirect_stdin_close {
    exec <&-
    exec <&5-
}
#@ pwiz_redirect_stdout_close
function pwiz_redirect_stdout_close {
    exec >&-
    exec >&6-
}
#@ pwiz_redirect_stdout_suspend
function pwiz_redirect_stdout_suspend {
    exec 8>&1
    exec >&6
}
#@ pwiz_redirect_stdout_restore
function pwiz_redirect_stdout_restore {
    exec >&8-
}
#@ pwiz_redirect_stdout
function pwiz_redirect_stderr_close {
    exec 2>&-
    exec 2>&7-
}

# pwiz_projectdirs_init
# initialize work directories for project.
# Call it every time you change $pwiz_project_* variables
function pwiz_projectdirs_init {
    local dir callback
    if test "$pwiz_project_project" = "" ; then
	dir=
    else
	dir="/$pwiz_project_project"
    fi
#@ Temporary directory for PWIZ modules, which is not cleaned after termination: $PWIZ_TMPDIR
#@ But can be cleaned in any time.
# WARNING: PWIZ_CACHEDIR is common for all projects!
# WARNING: Do not access here from pwiz_run
# NOTE: Use module name as prefix for all file names there.
    PWIZ_CACHEDIR=~/pwiz/tmpcache
#@ Temporary directory for PWIZ modules: $PWIZ_TMPDIR
# WARNING: Do not access here from pwiz_run
# NOTE: Use module name as prefix for all file names there.
    PWIZ_TMPDIR=~/pwiz/tmp$dir
#@ Temporary directory for PWIZ source codes: $PWIZ_SOURCESDIR
# WARNING: Do not write here from pwiz_run
    PWIZ_SOURCESDIR=~/pwiz/src$dir
#@ Temporary directory for PWIZ unpacked sources: $PWIZ_SRCDIR
# WARNING: Do not use this before SOURCE stage
# WARNING: In separate build dir mode do not write here after unpack stage
# WARNING: Do not write here from outside pwiz_run
    PWIZ_SRCDIR=~/pwiz/unpack$dir
#@ Temporary directory for PWIZ build: $PWIZ_BUILDDIR
# WARNING: Do not use this before PREPARE stage
# WARNING: Do not write here from outside pwiz_run
    PWIZ_BUILDDIR=~/pwiz/build$dir
#@ Temporary directory for PWIZ installation root: $PWIZ_INSTALLROOT
# WARNING: Do not use this before INSTALL stage
# WARNING: Do not write here before INSTALL stage
# WARNING: Do not write here from outside pwiz_run
    PWIZ_INSTALLROOT=~/pwiz/install$dir
#@ Directory for PWIZ results: $PWIZ_RESULTDIR
    PWIZ_RESULTDIR=~/pwiz/results$dir
    for callback in ${pwiz_projectdirs_init_callback[@]} ; do
	$callback "$dir"
    done
    mkdir -p $PWIZ_CACHEDIR
    rm -rf $PWIZ_TMPDIR/*
    mkdir -p $PWIZ_TMPDIR
    rm -rf $PWIZ_SOURCESDIR/*
    if test "$pwiz_project_project" != "" ; then
	mkdir -p $PWIZ_SOURCESDIR
	rm -rf $PWIZ_SRCDIR/*
	mkdir -p $PWIZ_SRCDIR
	rm -rf $PWIZ_BUILDDIR/*
	mkdir -p $PWIZ_BUILDDIR
	rm -rf $PWIZ_INSTALLROOT/*
	mkdir -p $PWIZ_INSTALLROOT
	mkdir -p $PWIZ_RESULTDIR
    fi
}

# pwiz_projectdirs_init_callback
# initialize work directories for project callback hook.
# Can redefine following variables: $PWIZ_SOURCESDIR, $PWIZ_SRCDIR, $PWIZ_BUILDDIR, $PWIZ_INSTALLROOT

#@ pwiz_array_add array_name item
# Add an item as last element of array.
# This is only simplification of array[${#array[@]}]=item
# NOTE: array_name is without leading $.
function pwiz_array_add {
    eval $1'[${#'$1'[@]}]="$2"'
}

#@ pwiz_set_rc return_code
#@ Helper, which only sets return code.
#@ Returns: return code
function pwiz_set_rc {
    return $1
}

# FIXME: TODO

# Check, whether $1 is integer.
function pwiz_check_int {
    :
}

# Check, whether $1 is natural.
function pwiz_check_natural {
    :
}

# Check, whether $1 is in p range (0-100).
function pwiz_check_p {
    :
}

#@ pwiz_find path [ path_prefix ] [ callback_argument_2 ]
#@ Input: $pwiz_callback: callback function (default is echo)
#@ A Bash alternative to simple recursive find for all files and links.
#@ $path_prefix mast have training slash, if used
#@ WARNING: If you want really all files, you must turn on dot globbing (shopt -s dotglob).
function pwiz_find {
    local item
    if test -d "$2$1" ; then
	for item in "$2$1/"* ; do
	    pwiz_find "${item#$2}" "$2" "$3"
	done
    else
	$pwiz_callback "${1#$2}" "$3"
    fi
}
pwiz_callback=echo

#@ pwiz_find_d path [ path_prefix ] [ callback_argument_3 ]
#@ Input: $pwiz_callback: callback function callback_argument_2 is file/dir (default is echo)
#@ A Bash alternative to simple recursive find for all dirs, files and links.
#@ $path_prefix mast have training slash, if used
#@ WARNING: If you want really all files, you must turn on dot globbing (shopt -s dotglob).
function pwiz_find_d {
    local item
    if test -d "$2$1" ; then
	$pwiz_callback "${1#$2}" dir "$3"
	for item in "$2$1/"* ; do
	    pwiz_find_d "${item#$2}" "$2" "$3"
	done
    else
	$pwiz_callback "${1#$2}" file "$3"
    fi
}

#@ pwiz_canonize
# Returns: Canonical form of file name in $pwiz_result
# NOTE: Does not canonize relative paths.
function pwiz_canonize {
    local old_name
    pwiz_result="$1"
# // -> /
    old_name=
    while test "$old_name" != "$pwiz_result" ; do
	old_name="$pwiz_result"
	pwiz_result="${pwiz_result//\/\///}"
    done
# /./ -> /
    old_name=
    while test "$old_name" != "$pwiz_result" ; do
	old_name="$pwiz_result"
	pwiz_result="${pwiz_result//\/.\///}"
    done
# /path/../ -> /
    shopt -s extglob
    old_name=
    while test "$old_name" != "$pwiz_result" ; do
	old_name="$pwiz_result"
	pwiz_result="${pwiz_result//\/*([^\/])\/../}"
    done
    shopt -u extglob
}

#@ pwiz_run
# FIXME: Does it work with multi-line strings?
# Run in protected build environment.
# Order of evaluation:
# pwiz_run_prepare - one function defined by build environment system (rpm, ebuild)
# pwiz_run_wrappers - chain of run wrappers defining environment protection (install watchers, sandboxing, run trace)
# pwiz_run_core - one function defined by build environment system, which does execution and sets pwiz_rc.

#@ pwiz_run_wrapper_register function
# Register wrapper for pwiz_run
# wrapper uses pwiz_run_wrap for subsequent call
#@ example:
#function mywrapper {
#    do_anything
#    operate_on "@" # returns ${result[]}
#    pwiz_run_wrap "${result[@]}"
#    do_the_rest
#}
#pwiz_run_wrapper_register mywrapper
function pwiz_run_wrapper_register {
    pwiz_run_function=$1
    eval 'function pwiz_run_wrap_'$pwiz_run_wrapper_count' {
    pwiz_run_wrap_function=pwiz_run_wrap_'$((pwiz_run_wrapper_count-1))'
    '$1' "$@"
}'
    pwiz_run_function=pwiz_run_wrap_$pwiz_run_wrapper_count
    let pwiz_run_wrapper_count++
}
pwiz_run_wrapper_count=1
pwiz_run_function=pwiz_run_core

function pwiz_run_wrap {
    $pwiz_run_wrap_function "$@"
}

#@ pwiz_run_wrap_0 (internal)
# Calls pwiz_run_core.
function pwiz_run_wrap_0 {
    pwiz_run_core "$@"
}
pwiz_run_rc=0

#@ pwiz_run_core args
# Immediatelly calls run args.
# Can be redefined by modules.
function pwiz_run_core {
    pwiz_set_rc $pwiz_run_rc
    "$@"
    pwiz_run_rc=$?
}

# pwiz_run_prepare
# Top level wrapper.
# After preparation calls $pwiz_run_function "$@"
# Can be redefined by modules.
function pwiz_run_prepare {
    $pwiz_run_function "$@"
}

#@ pwiz_run args
#@ Returns: Undefined!
#@ Returns: Return code of executed stage is also stored in $pwiz_run_rc.
#@ $pwiz_run_rc is restored before next pwiz_run.
#@ WARNING: Do not alter pwiz_run_rc!
function pwiz_run {
# FIXME: for debugging only:
# FIXME: Adopt other parts of run stuff to 1 arg
    if test "$2" != "" ; then
	pwiz_warning "2 arguments: pwiz_run $*"
    fi
    vvecho "running: $*"
    pwiz_run_prepare "$@"
}

#@ pwiz_run_eval args
# Expand variables, save them and then call pwiz_run
# FIXME: deprecated: replace by special phase with two stages
function pwiz_run_eval {
    pwiz_warning "deprecated: pwiz_run_eval $*"
    eval PWIZ_STAGE_EVAL_$PWIZ_PHASE_CURRENT\[$PWIZ_STAGE_CURRENT\]\=\"\$@\"
    eval pwiz_run "$@"
}

#@ pwiz_rem string
#@ Remark function. Action will appear in stage, but is not executed.
#@ Primarily intended for exporting comments to final build script.
# FIXME: multi-line
function pwiz_rem {
    :
}

#@ pwiz_rem_eval args
# Expand variables, save them and then call pwiz_rem
function pwiz_rem_eval {
    eval PWIZ_STAGE_EVAL_$PWIZ_PHASE_CURRENT\[$PWIZ_STAGE_CURRENT\]\=\"\$@\"
    eval pwiz_rem "$@"
}

#@ pwiz_debug level message
function pwiz_debug {
    echo "pwiz: $2"
}

#@ pwiz_fatal error
function pwiz_warning {
    eecho "Packaging wizard warning: $pwiz_module_current: $1"
}

#@ pwiz_fatal error
function pwiz_fatal {
    eecho "Packaging wizard fatal: $pwiz_module_current: $1"
    pwiz_exit 2
}

#@ pwiz_add_exit function
function pwiz_add_exit {
    PWIZ_EXIT="$PWIZ_EXIT
$1"
}
PWIZ_EXIT=

#@ pwiz_add_exit function
function pwiz_exit {
    eval $PWIZ_EXIT
    exit "$@"
}

#@ Error code for not implemented functions.
not_implemented=6

#@@ pwiz engines

# Engine description:
# Engine is a piece of bash code, inlined to main code.
# It typically implements an independent interface for communication with outer world.
# Arguments: module_name command
# Commands:
# desc: Shows description and return
# longdesc: Shows long description and return
# It must define all class specific functions:
# pwiz_engine_{engine_class}_{engine_name}_command
# Commands defined in pwiz_engine_interface, init, quit
# Module functions are called: pwiz_{engine_class}_command [ optional arguments ]

#@ pwiz_engine_desc class name
function pwiz_engine_desc {
    . ~/pwiz/engines/$1/$2.pwe desc
}

#@ pwiz_engine_longdesc class name
function pwiz_engine_longdesc {
    . ~/pwiz/engines/$1/$2.pwe longdesc
}

#@ pwiz_engine_load class name
function pwiz_engine_load {
    local interface i
    . ~/pwiz/engines/$1/$2.pwe
    pwiz_engine_${1}_${2}_init
    pwiz_add_exit pwiz_engine_${1}_${2}_quit
    eval interface\=\"\$PWIZ_ENGINE_INTERFACE_$1\"
    for i in init quit $interface
    do
	eval function pwiz_${1}_${i} "{
	    eval pwiz_engine_${1}_${2}_${i} \\\"\\\$@\\\"
	}"
    done
}

#@ pwiz_engine_list class
function pwiz_engine_list {
    (
	cd ~/pwiz/engines/$1
# FIXME not set, use pwiz_result instead of redirection
	ls -1 | sed 's/\.pwe$//'
    )
}

#@ pwiz_engine_interface class function1 function2 ...
function pwiz_engine_interface {
    local class
    class=$1
    shift
    eval PWIZ_ENGINE_INTERFACE_$class\=\"\$\*\"
}

#@@ cache engine

# Cache engine is designed for writing and and reading answers and
# other useful information in per-package, version, product basis.
# Address space is defined by keys. Keys are similar to filesystem
# paths.
# Returns result in $pwiz_result.

#@ pwiz_cache_read key
#@ pwiz_cache_read_tags key
# FIXME: WARNING: pwiz_cache_read_tags reads all tags in single string. To get particular tags, it must be further expanded by eval.
#@ pwiz_cache_write key value [tags]
#@ pwiz_cache_delete key
#@ pwiz_cache_list pattern
# NOTE: Patterns are standard path-element patterns.
# FIXME: Is this needed?:
# WARNING: at least for q element, subpatterns for question name must be accepted.
pwiz_engine_interface cache read read_tags write delete list

#@@ pkgdb engine

#@@ question engine

#@ pwiz_pkgdb_what_owns file [ files ]
# Returns: 0: OK
# Returns: 1: Problem.
# Returns: ${pwiz_result[@]}

#@ pwiz_pkgdb_package_to_project package
# Returns: $pwiz_result

pwiz_engine_interface pkgdb what_owns

# Question engine is iterface for communication with users. Engine
# asks user and waits for response.

# FIXME: question callback implementation:
# Any question will contain callbacked functions (it can be implementation background for "enter manually" and "help").

# FIXME: obsolete #@ pwiz_question_yesno desc longdesc [ tags ... ]
#@ Returns: 0: yes
#@ Returns: 1: false
#@ pwiz_question_radio desc longdesc [ tags ... ]
#@ Returns: $pwiz_answer with selection.
#@ pwiz_question_selection desc longdesc [ tags ... ]
#@ Returns: FIXME
#@ pwiz_question_string desc longdesc [ tags ... ]
#@ Returns: $pwiz_answer answer.
#@ pwiz_question_list desc longdesc [ tags ... ]
#@ Returns: FIXME

# FIXME: obsolete yesno
#pwiz_engine_interface question radio selection string list
pwiz_engine_interface question yesno radio selection string list

# Question engine is in most cases used through ask interface. It
# accomplishes question, caching answer and querying for reasonable
# guesses.

#@@ asking interface

#@ Read tags to variables.
# Tags are values entered as an argument of some functions in form: tag='value' other_tag[1]='other value'
# The alias defines local variables pwiz_tag_tag='value' pwiz_tag_other_tag[1]='other value'
# It uses special Bash tricks to prevent expansion or splitting of tags.
# If you want to prevent expansion at all, use set -o noglob in function alias.
alias pwiz_read_tags='local pwiz_tag ; for pwiz_tag in "$@" ; do eval local pwiz_tag_${pwiz_tag%%[=[]*} ; done ; for pwiz_tag in "$@" ; do pwiz_tag=${pwiz_tag/\'\''/\'\''\\\'\''\'\''}\'\'' ; pwiz_tag=${pwiz_tag/=/=\'\''} ; eval pwiz_tag_"$pwiz_tag" ; done'
# For better readability (needs ' -> '\''
# set -o noglob ; local pwiz_tag ; for pwiz_tag in "$@" ; do eval local pwiz_tag_${pwiz_tag%%=*} ; done ; for pwiz_tag in "$@" ; do pwiz_tag=${pwiz_tag/\'/\'\\\'\'}\' ; pwiz_tag=${pwiz_tag/=/=\'} ; eval pwiz_tag_"$pwiz_tag" ; done ; set +o noglob

# Asking interface is used for querying users, saving and re-using results.

#@ keys for question id
pwiz_key_list="project subproject version patchlevel vendor product pversion build"

#@ Set local key variables from global ones.
#alias pwiz_keys_set='local project subproject version patchlevel vendor product pversion build ; project=$pwiz_project_project subproject=$pwiz_project_subproject version=$pwiz_project_version patchlevel=$pwiz_project_patchlevel vendor=$pwiz_project_vendor product=$pwiz_project_product pversion=$pwiz_project_pversion build=$pwiz_project_build'
alias pwiz_keys_set='local pwiz_key ; for pwiz_key in $pwiz_key_list ; do local $pwiz_key ; eval $pwiz_key\=\$pwiz_project_$pwiz_key ; done'

#@ cache validities

# Cache validities removes values unappropriate for defined validity range.
# Other types can be defined in modules.
# In ask engine are used without leading pwiz_cache_validity_.

#@ Apply validity restrictions.
alias pwiz_cache_validity_apply='local pwiz_cache_validity=pwiz_cache_validity_"$pwiz_tag_valid" ; if test "$(type -t "$pwiz_cache_validity")" != function ; then pwiz_fatal "invalid validitity range $pwiz_tag_valid (tag \"valid\")" ; fi ; $pwiz_cache_validity'

# All entries are valid.
function pwiz_cache_validity_exact {
    :
}

# Checking of unpacked sources.
function pwiz_cache_validity_source {
    patchlevel=@
    vendor=@
    product=@
    pversion=@
    build=@
}

# Vendor's policy, independent on package.
function pwiz_cache_validity_vendor {
    project=@
    subproject=@
    version=@
    patchlevel=@
    build=@
}

# PWIZ setup. No dependence on package or anything else. Used for PWIZ preferences.
function pwiz_cache_validity_setup {
    project=@
    subproject=@
    version=@
    patchlevel=@
    vendor=@
    product=@
    pversion=@
    build=@
}

# Per-project information, independent on vendor.
function pwiz_cache_validity_project {
    subproject=@
    version=@
    patchlevel=@
    vendor=@
    product=@
    pversion=@
    build=@
}

# Vendor's policy for project.
function pwiz_cache_validity_product {
    subproject=@
    version=@
    patchlevel=@
    build=@
}

#@@ guess interface

# Guess interface uses cached answer to guess answer for new question.

#@ Guess trust levels

# Guess trust levels are functions defining ability to trust answers,
# based on comparison of particular key. Trust level function has
# access to other values, which can be used for guess.

pwiz_debug_feature guess

#@ pwiz_guess_trust_{key}
# Function compares keys and returns
# Returns value 0-100 in $pwiz_trust.
#@tags inherit: Trust inheritance level between versions.
function pwiz_guess_trust_version {
    pwiz_read_tags
    if test "$pwiz_project_version" = "$pwiz_item_version" ; then
	pwiz_trust=100
    else
	pwiz_trust=$pwiz_tag_inherit
    fi
}
# Default version inheritance of answers.
pwiz_tag_inherit=80

#@ pwiz_guess [ tags ]
# Returns array of ${pwiz_guesses[]}, ${pwiz_strings[]} (optional), ${pwiz_hotkeys[]} (optional), ${pwiz_trusts[]} for possible answers and $pwiz_guess_best
# with index of best guess and $pwiz_guess_best_value.
# FIXME: Implement knowledge!!!
#@tags default, p, string, hotkey: Array tags of guess descriptions.
#@tags q: Question ID.
#@tags valid: Validity range.
#@tags id, after, before: Tags for ordered lists.
function pwiz_guess {
    local key_found is_new tags count v_total v_default v_p v_string v_hotkey callback

    pwiz_read_tags
    pwiz_keys_set
    local pwiz_key
    for pwiz_key in $pwiz_key_list ; do
	if test "$(type -t "pwiz_guess_trust_$pwiz_key")" = function ; then
	    eval $pwiz_key\=\'\*\'
	fi
    done
    pwiz_cache_validity_apply

    unset pwiz_guesses pwiz_trusts pwiz_strings pwiz_hotkeys

    # Defaults for Boolean.
    if $pwiz_tag_yesno ; then
	pwiz_guesses[0]="false"
	pwiz_trusts[0]=0
	pwiz_strings[0]="no"
	pwiz_hotkeys[0]="n"
	pwiz_guesses[1]="true"
	pwiz_trusts[1]=0
	pwiz_strings[1]="yes"
	pwiz_hotkeys[1]="y"
    fi

    # callback of pwiz_guess_callback_{q}[*]
    if ! test -z "$pwiz_tag_q" ; then
	eval 'for callback in ${pwiz_guess_callback_'"$pwiz_tag_q"'[@]} ; do
	    $callback
	done'
    fi

    # parse guesses in tags
    for (( count=0 ; count < ${#pwiz_tag_default[@]} ; count++ )) ; do
	decho_guess "guess in tags ${pwiz_tag_default[count]} (${pwiz_tag_p[count]}%)"
	pwiz_guess_eval "${pwiz_tag_default[count]}" ${pwiz_tag_p[count]}\
	    "${pwiz_tag_string[count]}" "${pwiz_tag_hotkey[count]}"
    done

    if ! test -z "$pwiz_tag_q" ; then

	# parse guesses in environment variables pwiz_guess_default_{q} pwiz_guess_p_{q}, pwiz_guess_string_{q} pwiz_guess_hotkey_{q}
	# WARNING: Those quesses does not recomputed p
	eval v_total\=\${#pwiz_guess_default_$pwiz_tag_q\[@\]}
	for (( count=0 ; count < v_total ; count++ )) ; do
	    eval v_default\=\"\${pwiz_guess_default_$pwiz_tag_q\[count\]}\"
	    eval v_p\=\${pwiz_guess_p_$pwiz_tag_q\[count\]}
	    eval v_string\=\"\${pwiz_guess_string_$pwiz_tag_q\[count\]}\"
	    eval v_hotkey\=\"\${pwiz_guess_hotkey_$pwiz_tag_q\[count\]}\"
	    decho_guess "found guess in variable $v_default ($v_p%)"
	    pwiz_guess_eval "$v_default" "$v_p" "$v_string" "$v_hotkey"
	done

    # parse cached guesses
	decho_guess "cache query:  $pwiz_tag_q/$project/$subproject/$version/$patchlevel/$vendor/$product/$pversion/$build"
	pwiz_cache_list "$pwiz_tag_q/$project/$subproject/$version/$patchlevel/$vendor/$product/$pversion/$build"
	for key_found in $pwiz_result ; do
	    decho_guess "found: $key_found"
	    pwiz_key_parse $key_found
	    pwiz_cache_read_tags $key_found
	    tags="$pwiz_result"
	    pwiz_cache_read $key_found
	    eval pwiz_guess_trust "$tags"
# FIXME: Maybe parse tags to find string and hotkey.
	    pwiz_guess_eval "$pwiz_result" "$pwiz_trust" "" ""
	    decho_guess "result: $pwiz_result"
	    decho_guess "trust: $pwiz_trust"
	done

    fi

    pwiz_guess_best_value=@@PWIZ_UNDEFINED@@
    local best_guess_trust=0
    pwiz_guess_best=-1
    for (( count=0 ; count < ${#pwiz_guesses[*]} ; count++ )) ; do
	decho_guess "guess[$count]: \"${pwiz_guesses[count]}\" trust=${pwiz_trusts[count]}"
	if test "${pwiz_trusts[count]}" -ge $best_guess_trust ; then
	    best_guess_trust=${pwiz_trusts[count]}
	    pwiz_guess_best=$count
	    pwiz_guess_best_value="${pwiz_guesses[count]}"
	fi
    done
    decho_guess "available guesses: ${#pwiz_guesses[*]}"
    decho_guess "best guess $pwiz_guess_best: $pwiz_guess_best_value"
}
declare -a pwiz_guesses pwiz_trusts
# Trust level of unknown source.
pwiz_tag_trust=50
# Trust level of automatic guesses.
# FIXME: Should be dependent on knowledge tag.
pwiz_auto_guess=50
# Default is undefined (definition prevents collision with empty strung default).
unset pwiz_tag_default

#@ pwiz_guess_eval guess trust string hotkey
#@ Evaluate guess for guess array in pwiz_guess (internal) or in callback.
function pwiz_guess_eval {
    local count
    local is_new=true
    for (( count=0 ; count < ${#pwiz_guesses[*]} ; count++ )) ; do
	if test "${pwiz_guesses[count]}" = "$1" ; then
	    if test $2 -gt ${pwiz_trusts[count]} ; then
		pwiz_trusts[count]=$2
	    fi
	    is_new=false
	    break
	fi
    done
# FIXME: Maybe test -z is not required.
    if $is_new ; then
	pwiz_trusts[${#pwiz_guesses[*]}]=$2
	if ! test -z "$3" ; then
	    pwiz_strings[${#pwiz_guesses[*]}]="$3"
	fi
	if ! test -z "$4" ; then
	    pwiz_hotkeys[${#pwiz_guesses[*]}]="$4"
	fi
	pwiz_array_add pwiz_guesses "$1"
    else
	if test -z "${pwiz_strings[count]}" -a ! -z "$3" ; then
	    pwiz_strings[count]="$3"
	fi
	if test -z "${pwiz_hotkeys[count]}" -a ! -z "$4" ; then
	    pwiz_hotkeys[count]="$4"
	fi
    fi
}


#@ pwiz_guess_add q value p [ string hotkey ]
#@ Add predefined guess to environment variables pwiz_guess_default_{q} pwiz_guess_p_{q} and pwiz_guess_string_{q}
# WARNING: Those quesses does not recomputed p
function pwiz_guess_add {
    eval local count\=\${#pwiz_guess_default_$1\[@\]}
    eval pwiz_guess_default_$1\[count\]\=\"\$2\"
    eval pwiz_guess_p_$1\[count\]\=\"\$3\"
    if ! test -z "$4" ; then
	eval pwiz_guess_string_$1\[count\]\=\"\$4\"
    fi
    if ! test -z "$5" ; then
	eval pwiz_guess_hotkey_$1\[count\]\=\"\$5\"
    fi
set >/tmp/set
}

#@ pwiz_guess_trust [tags] (internal function)
# Computes trust value for key found
#@tags trust: Trust level of cache source.
function pwiz_guess_trust {
    pwiz_read_tags

    local pwiz_key subtrust=$pwiz_tag_trust
    for pwiz_key in $pwiz_key_list ; do
	if test "$(type -t "pwiz_guess_trust_$pwiz_key")" = function ; then
	    eval pwiz_guess_trust_$pwiz_key
	    let subtrust=subtrust\*pwiz_trust/100
	fi
    done
    pwiz_trust=$subtrust
}

#@ pwiz_key_parse key
# Returns variables pwiz_item_{key}
function pwiz_key_parse {
    local keys pwiz_key
    keys=$1
    for pwiz_key in q $pwiz_key_list ; do
	eval pwiz_item_$pwiz_key\=\${keys%%/\*}
	keys=${keys#*/}
    done
}

#@ pwiz_ask_core question_function desc longdesc [ tags ... ]
# Generic asking interface function.
# Returns in variable $pwiz_answer and $pwiz_answer_{question}
#@tags knowledge: Knowledge type required for answer.
#@tags q: Question ID.
# FIXME: implement callbacks for defaut for all questions pwiz_ask_callback_{question}
function pwiz_ask_core {
    local question_function desc longdesc rc knowledge count hotkey
    question_function=$1
    desc="$2"
    longdesc="$3"
    shift 3
    pwiz_read_tags
    pwiz_keys_set
    pwiz_cache_validity_apply

    decho_guess "query tags: $*"
    if ! test -z "$pwiz_tag_q" ; then
	eval pwiz_answer\=\"\${pwiz_answer_$pwiz_tag_q-@@PWIZ_UNDEFINED@@}\"
	if test "$pwiz_answer" != @@PWIZ_UNDEFINED@@ ; then
	    decho_guess "already answered: $pwiz_answer"
	    return
	fi
    fi
    pwiz_guess "$@"

    unset pwiz_hotarray
    # Search for unique hotkeys.
# FIXME: elsewhere???
    pwiz_hotarray[64#h]=h
    # hotkey for manual is currently reserved (maybe others want to be reserved)
    if $pwiz_tag_allow_new ; then
	pwiz_hotarray[64#m]=m
    fi
    for (( count=0 ; count < ${#pwiz_guesses[*]} ; count++ )) ; do
	hotkey="${pwiz_hotkeys[$count]}"
	if ! test -z "$hotkey" ; then
	    if test -z "${pwiz_hotarray[64#$hotkey]}" ; then
		pwiz_hotarray[64#$hotkey]=$count
	    else
		unset pwiz_hotkeys[$count]
	    fi
	fi
    done

    $question_function "$desc" "$longdesc" "$@"
    rc=$?

    # FIXME: check for undefined value.
    # FIXME: implement delayed write (write to cache if module confirms or command is successfull).
    eval knowledge\=\$pwiz_knowledge_$pwiz_tag_knowledge
    if ! test -z "$pwiz_tag_q" ; then
	pwiz_cache_write $pwiz_tag_q/$project/$subproject/$version/$patchlevel/$vendor/$product/$pversion/$build "$pwiz_answer" "$@" trust=$knowledge
	eval pwiz_answer_$pwiz_tag_q\=\"\$pwiz_answer\"
    fi

    return $rc
}
pwiz_tag_valid=exact
pwiz_tag_knowledge=general

#@ pwiz_ask_{function}
# Functions for programmers.
# Special note: For parsing arguments of pwiz_ask_{function}, globbing is temporarilly turned off.
# It's because, for example default[1]=* can be expanded to file name
# "default3=dummy", if such file exists.

# FIXME: The backend can use two ways: special yesno function or use it via string input.

alias pwiz_ask_yesno="set -o noglob ; pwiz_ask_yesno_f"
function pwiz_ask_yesno_f {
    set +o noglob
    local rc
#    pwiz_ask_core pwiz_question_yesno "$@"
    local desc="$1"
    local longdesc="$2"
    shift 2
    pwiz_read_tags
    pwiz_ask_core pwiz_question_string "$desc" "$longdesc" yesno=true allow_new=false "$@"
    if $pwiz_answer ; then
	return
    else
	return 1
    fi
}
pwiz_tag_yesno=false

#@tags callback: Callback function for "enter manually" (returns $pwiz_answer).
#@tags allow_new: if set to false, "enter manually" is disabled (default: true).
alias pwiz_ask_string="set -o noglob ; pwiz_ask_string_f"
function pwiz_ask_string_f {
    set +o noglob
    pwiz_ask_core pwiz_question_string "$@"
}
pwiz_tag_allow_new=true

alias pwiz_ask_radio="set -o noglob ; pwiz_ask_radio_f"
function pwiz_ask_radio_f {
    echo "*** FIXME: pwiz_ask_radio is obsolete. Use pwiz_ask_string with tag allow_new=false"
    set +o noglob
    pwiz_ask_core pwiz_question_radio "$@"
}

# FIXME: implement pwiz_ask_selection

#@tags callback: Callback function for "new item" (returns $pwiz_answer).
#@tags item_type: List item type (default: string).
#@ Prepares for backend: pwiz_list_all - list of active entries in cache (in form q=${q}_${list_item}) (with leading and trailing space)
#@ FIXME: Maybe {key}_{tag} can be reduced to {tag} while calling subsequent questions
#@ FIXME: Tag default is not implemented
#@ FIXME: Implement text representation support
#@ FIXME: Implement block tag (if block tag is in best guess, item will not be included in pwiz_list_all).
alias pwiz_ask_list="set -o noglob ; pwiz_ask_list_f"
function pwiz_ask_list_f {
    set +o noglob

    local desc longdesc key_found is_new list_key list_count

    desc="$1"
    longdesc="$2"
    shift 2
    pwiz_read_tags
    pwiz_keys_set
    local pwiz_key
    for pwiz_key in $pwiz_key_list ; do
	if test "$(type -t "pwiz_guess_trust_$pwiz_key")" = function ; then
	    eval $pwiz_key\=\'\*\'
	fi
    done
    pwiz_cache_validity_apply

    if test -z "$pwiz_tag_q" ; then
	pwiz_fatal "pwiz_ask_list must contain tag q"
    fi

    pwiz_list_all=
    decho_guess "list query: $pwiz_tag_q/$project/$subproject/$version/$patchlevel/$vendor/$product/$pversion/$build"
    pwiz_cache_list "${pwiz_tag_q}_*/$project/$subproject/$version/$patchlevel/$vendor/$product/$pversion/$build"
    for key_found in $pwiz_result ; do
	decho_guess "list found: $key_found"
	pwiz_key_parse $key_found
	is_new=true
	list_count=0
	for list_key in $pwiz_list_all ; do
	    if test "$list_key" = "$pwiz_item_q" ; then
		is_new=false
		break
	    fi
	done
	if $is_new ; then
	    eval 'pwiz_list_all="$pwiz_list_all ${pwiz_item_q#'$pwiz_tag_q'_}"'
	fi
    done
    pwiz_list_all="$pwiz_list_all "
    decho_guess "list completed: \"$pwiz_list_all\""

    pwiz_ask_core pwiz_question_list "$desc" "$longdesc" "$@"

}
pwiz_tag_item_type=string

#@ callback [ tags ]
# Returns $pwiz_answer with result.

#@@ stages / phases / steps

#@ pwiz_phase_new phase_id { "after" | "before" } phase_id [ ok ]
# ok means: "Ignore, if phase already exists."
function pwiz_phase_new {
    local tmp_phase
    eval tmp_phase\=\$PWIZ_PHASE_AFTER_$3
    if test "$tmp_phase" = "" ; then
	pwiz_fatal "cannot create new phase $1 $2 $3 - $3 is unknown"
    fi
    eval tmp_phase\=\$PWIZ_PHASE_AFTER_$1
    if test "$tmp_phase" = "" ;	then
	case "$2" in
	    after )
		eval tmp_phase\=\$PWIZ_PHASE_AFTER_$3
		eval PWIZ_PHASE_AFTER_$3\=$1
		eval PWIZ_PHASE_BEFORE_$1\=$3
		eval PWIZ_PHASE_AFTER_$1\=$tmp_phase
		eval PWIZ_PHASE_BEFORE_$tmp_phase\=$1
		;;
	    before )
		eval tmp_phase\=\$PWIZ_PHASE_BEFORE_$3
		eval PWIZ_PHASE_AFTER_$tmp_phase\=$1
		eval PWIZ_PHASE_BEFORE_$1\=$tmp_phase
		eval PWIZ_PHASE_AFTER_$1\=$3
		eval PWIZ_PHASE_BEFORE_$3\=$1
		;;
	    * )
		pwiz_fatal "bad specification of phase insertion type"
	esac
	eval declare -a PWIZ_STAGE_$1
	eval declare -a PWIZ_STAGE_EVAL_$1
    else
	if test "$3" != "ok" ; then
	    pwiz_fatal "phase $1 already exists"
	fi
    fi
}
PWIZ_PHASE_AFTER_BEGIN=END
PWIZ_PHASE_BEFORE_END=BEGIN

#@ pwiz_phase_list
function pwiz_phase_list {
    eval local phase\=\$PWIZ_PHASE_AFTER_BEGIN
    while [ $phase != END ] ; do
	echo $phase
	eval phase\=\$PWIZ_PHASE_AFTER_$phase
    done
}

#@ pwiz_phase_add phase contents
function pwiz_phase_add {
# FIXME: for debugging only:
    if test "$3" != "" ; then
	pwiz_fatal "3 arguments: pwiz_phase_add $*"
    fi
    local tmp_phase
    eval tmp_phase\=\$PWIZ_PHASE_AFTER_$1
    if test "$tmp_phase" = "" ; then
	pwiz_fatal "cannot add to phase $1 - phase does not exist"
    fi
    pwiz_array_add PWIZ_STAGE_$1 "$2"
}

#@ pwiz_phase_add_callme phase [ arg ]
# phase===argument
#@ similar to pwiz_phase_add_exec phase contents
# FIXME with pwiz_module_exec: In future, argumentless version will call function named as module
function pwiz_phase_add_callme {
# FIXME: for debugging only:
    if test "$3" != "" ; then
	pwiz_fatal "3 arguments: pwiz_phase_add_callme $*"
    fi
    if test "$pwiz_module_current" = "ERROR" ; then
	pwiz_fatal "pwiz_phase_add_callme called outside init"
    fi
    pwiz_phase_add "$1" "${pwiz_module_current}_$1${2:+ $2}"
}

#@ pwiz_phase_new_callme phase [ after | before ] phase_id contents
# phase===argument
#@ similar to pwiz_phase_new phase ; pwiz_phase_add_exec phase contents
# FIXME with pwiz_module_exec: In future, argumentless version will call function named as module
function pwiz_phase_new_call {
# FIXME: for debugging only:
    if test "$5" != "" ; then
	pwiz_fatal "5 arguments: pwiz_phase_new_call $*"
    fi
    pwiz_phase_new "$1" "$2" "$3"
    pwiz_phase_add "$1" "$1${4:+ $4}"
}

#@ pwiz_phase_new_3 phase [ after | before ] phase_id
#@ create all needed for "three phase method"
# FIXME: comments are out of date
#@ see more for documantation for its purpose
#@ adds three phases:
#@   {phase}_prepare with default contents callme
#@   phase default empty
#@   {phase}_set with default contents callme
#@ function {phase}_provider adding callme to phase
#@   {phase}_provider (no args)
function pwiz_phase_new_3 {
    pwiz_phase_new_call $1_prepare $2 $3
    pwiz_phase_new $1 after $1_prepare
    pwiz_phase_new_call $1_set after $1
    eval "function $1_provider {
    pwiz_phase_add_callme $1
}"
}

#@ pwiz_phase_new_3_guess phase [ after | before ] phase_id
#@ pwiz_phase_new_3 + create guess function
#@ create all needed for "three phase method" with simple guess addition
#@ see more for documantation for its purpose
#@ adds three phases:
#@   {phase}_prepare with default contents callme
#@   phase default empty
#@   {phase}_set with default contents callme
#@ function {phase}_provider adding callme to phase
#@   {phase}_provider (no args)
#@ function {phase}_guess for adding callme to phase
#@   {phase}_guess guess p [ string ]
#@ variables
#@   $package_basename_guesses variable with defaults for pwiz_ask_*
#@ $package_basename_guesses_count - if you want to provide own
#@    defaults, you need to set to #defaults in {phase}_prepare. Otherwise
#@    not needed.
function pwiz_phase_new_3_guess {
#    pwiz_phase_new $1_prepare $2 $3
    pwiz_phase_new_call $1_prepare $2 $3
#    pwiz_phase_add $1_prepare "$1_guesses_count=0 $1_guesses="
#    pwiz_phase_add_callme $1_prepare
    pwiz_phase_new $1 after $1_prepare
    pwiz_phase_new_call $1_set after $1
    eval "function $1_provider {
    pwiz_phase_add_callme $1
}"
    eval "function $1_guess {
    pwiz_guess_add $1 \"\$1\" \"\$2\" \"\$3\"
}"
}

#@ pwiz_phase_add_run phase contents
#@ similar to pwiz_phase_add_run phase pwiz_run contents
# Adds protected run command.
function pwiz_phase_add_run {
# FIXME: for debugging only:
    if test "$3" != "" ; then
	pwiz_fatal "3 arguments: pwiz_phase_add_run $*"
    fi
    pwiz_phase_add "$1" "pwiz_run $2"
}

#@ pwiz_phase_add_run_eval phase contents
#@ similar to pwiz_phase_add_run phase pwiz_run eval contents
# Adds protected run command with shell evaluation in time of call.
# WARNING: Remember not to expand variables, i. e. use single quotes or backslashes.
function pwiz_phase_add_run_eval {
# FIXME: for debugging only:
    pwiz_warning "deprecated: pwiz_phase_add_run_eval $*"
    if test "$3" != "" ; then
	pwiz_fatal "3 arguments: pwiz_phase_add_run_eval $*"
    fi
    pwiz_phase_add "$1" "pwiz_run_eval $2"
}

#@ pwiz_phase_add_call phase argument contents
#@ similar to pwiz_phase_add_exec phase contents
function pwiz_phase_add_rem {
# FIXME: for debugging only:
    if test "$3" != "" ; then
	pwiz_fatal "3 arguments: pwiz_phase_add_rem $*"
    fi
    pwiz_phase_add "$1" "pwiz_rem $2"
}

#@ pwiz_phase_add_call phase argument contents
#@ similar to pwiz_phase_add_exec phase contents
function pwiz_phase_add_rem_eval {
    if test "$3" != "" ; then
	pwiz_fatal "3 arguments: pwiz_phase_add_rem_eval $*"
    fi
    pwiz_phase_add "$1" "pwiz_rem_eval $2"
}
#@ pwiz_phase_check phase arguments
# Special command for init
function pwiz_phase_check {
    pwiz_array_add PWIZ_STAGE_$1 "$pwiz_module_current $2"
}

#@ pwiz_phase_clean phase
function pwiz_phase_clean {
    eval unset -a PWIZ_STAGE_$1
    eval declare -a PWIZ_STAGE_$1
}

#@ pwiz_stage_next
# Next stage.
#@ Returns: 0 OK
#@ Returns: 1 No next stage.
function pwiz_stage_next {
    local pwiz_step_phase_stages
    eval pwiz_step_phase_stages=\${#PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[\*\]}
    let PWIZ_STAGE_CURRENT++
    if test $PWIZ_STAGE_CURRENT -ge $pwiz_step_phase_stages ; then
	return 1
    else
	return 0
    fi
}

#@ pwiz_stage_prev
# Previous stage.
#@ Returns: 0 OK
#@ Returns: 1 No next stage.
function pwiz_stage_prev {
    local pwiz_step_phase_stages
    eval pwiz_step_phase_stages=\${#PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[\*\]}
    let PWIZ_STAGE_CURRENT--
    if test $PWIZ_STAGE_CURRENT -lt -1 ; then
	return 1
    else
	return 0
    fi
}

#@ pwiz_stage_goto stage
# Goto any stage.
#@ Returns: 0 OK
#@ Returns: 1 No next stage.
function pwiz_stage_goto {
    local pwiz_step_phase_stages
    eval pwiz_step_phase_stages=\${#PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[\*\]}
    PWIZ_STAGE_CURRENT=$1
    if test $PWIZ_STAGE_CURRENT -lt -1 ; then
	return 1
    else
	return 0
    fi
}

function pwiz_stage_prev {
    local pwiz_step_phase_stages
    eval pwiz_step_phase_stages=\${#PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[\*\]}
    let PWIZ_STAGE_CURRENT--
    if test $PWIZ_STAGE_CURRENT -ge $pwiz_step_phase_stages -o $PWIZ_STAGE_CURRENT -lt -1 ; then
	return 1
    else
	return 0
    fi
}

#@ pwiz_phase_next
#@ Returns: 0 OK
#@ Returns: 1 No next phase.
function pwiz_phase_next {
    local pwiz_step_phase_stages
    while : ; do
	eval PWIZ_PHASE_CURRENT\=\$PWIZ_PHASE_AFTER_$PWIZ_PHASE_CURRENT
	if [ $PWIZ_PHASE_CURRENT = END ] ; then
	    return 1
	fi
	eval pwiz_step_phase_stages=\${#PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[\*\]}
	if test $pwiz_step_phase_stages -eq 0 ; then
	    vvecho "Skipping empty phase $PWIZ_PHASE_CURRENT..."
	else
	    break
	fi
    done
    PWIZ_STAGE_CURRENT=-1
    vecho "Entering phase $PWIZ_PHASE_CURRENT..." >&2
}

#@ pwiz_phase_prev
#@ Returns: 0 OK
#@ Returns: 1 No prev phase.
# Note: sets stage counter to first stage, not last!
# Warning: If previous phase is empty, it skips back. It is not reverse fonction to pwiz_phase_next.
function pwiz_phase_prev {
    local pwiz_step_phase_stages
    eval PWIZ_PHASE_CURRENT\=\$PWIZ_PHASE_BEFORE_$PWIZ_PHASE_CURRENT
    if [ $PWIZ_PHASE_CURRENT = BEGIN ] ; then
	return 1
    fi
    eval pwiz_step_phase_stages=\${#PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[\*\]}
    if test $pwiz_step_phase_stages -eq 0 ; then
	pwiz_phase_next
    else
	PWIZ_STAGE_CURRENT=-1
	vecho "Entering phase $PWIZ_PHASE_CURRENT..." >&2
    fi
}

#@ pwiz_phase_goto phase
#@ Returns: 0 OK
#@ Returns: 1 Bad phase name.
# Note: sets stage counter to first stage, not last!
# Warning: If phase is empty, it skips forward.
function pwiz_phase_goto {
    local pwiz_step_phase_stages pwiz_phase_save
    pwiz_phase_save=$PWIZ_PHASE_CURRENT
    eval PWIZ_PHASE_CURRENT\=\$PWIZ_PHASE_BEFORE_$1
    if test -z "$PWIZ_PHASE_CURRENT" ; then
	PWIZ_PHASE_CURRENT=$pwiz_phase_save
	return 1
    fi
    PWIZ_PHASE_CURRENT=$1
    PWIZ_STAGE_CURRENT=-1
    eval pwiz_step_phase_stages=\${#PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[\*\]}
    if test $pwiz_step_phase_stages -eq 0 ; then
	pwiz_phase_next
    else
	vecho "Entering phase $PWIZ_PHASE_CURRENT..." >&2
    fi
}

# pwiz_next
#@ Returns: 0 OK
#@ Returns: 1 No next phase or stage.
function pwiz_next {
    if ! pwiz_stage_next ; then
	if pwiz_phase_next ; then
	    PWIZ_STAGE_CURRENT=0
	else
	    return 1
	fi
    fi
}

#@ pwiz_step action
#@ Returns: 0 Phase and stage exists and executed.
#@ Returns: 1 No next stage and phase.
#@ Returns: Return code of executed stage is in $pwiz_rc (if any).
#@ WARNING: Return code is not return code of executed stage!
#@ WARNING: pwiz_step first increments counters, then executes - reverse order does not enable roll-ons.
function pwiz_step {
    local pwiz_step_stage_code rc
    if pwiz_next ; then
	vvecho "Entering stage $PWIZ_PHASE_CURRENT[$PWIZ_STAGE_CURRENT]..." >&2
	eval pwiz_step_stage_code=\"\${PWIZ_STAGE_$PWIZ_PHASE_CURRENT\[$PWIZ_STAGE_CURRENT\]}\"
	case $1 in
	    query )
		pwiz_result="$pwiz_step_stage_code"
		;;
	    run )
# FIXME pwiz_rem and pwiz_rem_eval
		vvecho -e "Running: $pwiz_step_stage_code"
# FIXME: pwiz_rune does not need this expansion, but direct run yes
# Do it better, this is a hack.
		if $OPTARG_PROMPT ; then
		    pwiz_prompt +
		fi
		if test "${pwiz_step_stage_code%% *}" = pwiz_run ; then
		    $pwiz_step_stage_code
		else
		    eval "$pwiz_step_stage_code"
		fi
		pwiz_rc=$?
		if $OPTARG_PROMPT ; then
		    pwiz_prompt -
		fi
		;;
	esac
	return 0
    else
	return 1
    fi
}

#@ pwiz_phase_reset
# reset phase engine
function pwiz_phase_reset {
    PWIZ_PHASE_CURRENT=BEGIN
    PWIZ_STAGE_CURRENT=0
}
pwiz_phase_reset

#@ pwiz_phase_save
# save phase engine state
function pwiz_phase_save {
    PWIZ_PHASE_CURRENT_save=$PWIZ_PHASE_CURRENT
    PWIZ_STAGE_CURRENT_save=$PWIZ_STAGE_CURRENT
}

#@ pwiz_phase_restore
# restore phase engine state
function pwiz_phase_restore {
    PWIZ_PHASE_CURRENT=$PWIZ_PHASE_CURRENT_save
    PWIZ_STAGE_CURRENT=$PWIZ_STAGE_CURRENT_save
    unset PWIZ_PHASE_CURRENT_save PWIZ_STAGE_CURRENT_save
}


#@@ checkpoints

# Checkpoints are special phases intended for manual selection of
# special actions. User is not disturbed by lots of questions with
# expected negative answer for most of them, but is queried only by one
# question with chance to select list.

# FIXME: each action can be included only once. Is it correct?

#@ pwiz_checkpoint_new id [ after | before ] phase "Short desc" "Long desc"
function pwiz_checkpoint_new {
    pwiz_phase_new "$1" "$2" "$3"
    pwiz_phase_add "$1" "pwiz_checkpoint_ask $1"
    eval pwiz_checkpoint_desc_$1\=\"\$4\"
    eval pwiz_checkpoint_longdesc_$1\=\"\$5\"
}

#@ pwiz_checkpoint_ask id (internal)
function pwiz_checkpoint_ask {
    local item
    pwiz_ask_list "$4" \"$5\" q=checkpoint_$1 allow_new=false
    for item in $pwiz_answer ; do
	pwiz_phase_add "$1" "$item"
    done
}

# FIXME: what description is correct
#@ pwiz_checkpoint_add phase_id "Short desc" "Long desc" q=question_id [tags]
#@ pwiz_checkpoint_add phase_id function [ string hotkey ]
function pwiz_checkpoint_add {
    pwiz_guess_add "$1" "$2" 0 "$3" "$4"
}

#@@ modules

# FIXME: Check - module must not contain "-" and similar characters (only alphanum and @).

# Module description:
# Module is a piece of bash code, inlined to main code.
# It typically implements package checks, expert system knowledges and its infrastructure.
# Arguments: module_name command [ optional arguments ]
# Mandatory commands:
# desc: Shows description and return
# longdesc: Shows long description and return
# init: Initialize engine. Before engine initialization, it is called once without arguments.
# version: Shows module version
# Other commands:
# {command}: User space commands
# Module functions are called: pwiz_module_exec module command  [ optional arguments ]
# $pwiz_module_current is defined all the time and contains current module name

#@ pwiz_modules_list
function pwiz_modules_list {
    local file
    (
	cd ~/pwiz/modules
# FIXME: Use pwiz_result instead of redirection
	for file in *.pwm ; do
#FIXME for debugging only
	    if [ "${file:$((${#file}-1))}" = "~" ] ; then
		continue
	    fi
	    echo ${file%.pwm}
	done
    )
}

#@ pwiz_modules_load
function pwiz_modules_load {
    local file
	for file in $(pwiz_modules_list) ; do
	    if test $OPTCNT_VERBOSE -ge 1 ; then
		if test $OPTCNT_VERBOSE -ge 2 ; then
		    echo "Loading module $file ($(pwiz_module_desc $file))..."
		    if test $OPTCNT_VERBOSE -ge 3 ; then
			pwiz_module_longdesc $file
		    fi
		else
		    echo "Loading module $file..."
		fi
	    fi
	    pwiz_module_load $file
	done
}

#@ pwiz_module_desc name
function pwiz_module_desc {
    . ~/pwiz/modules/$1.pwm desc
}

#@ pwiz_module_longdesc name
function pwiz_module_longdesc {
    . ~/pwiz/modules/$1.pwm longdesc
}

pwiz_module_current="ERROR"

#@ pwiz_module_load module_name
function pwiz_module_load {
    local loaded pwiz_module_current_save
    eval loaded\=\"\$PWIZ_MODULE_LOADED_$1\"
    if test -z "$loaded" ; then
	pwiz_module_include $1 init
	eval PWIZ_MODULE_LOADED_$1\=1
    fi
}

# FIXME: rename to pwiz_module_exec
function pwiz_module_include {
    local pwiz_module_current_save
    pwiz_module_current_save="$pwiz_module_current"
    pwiz_module_current=$1
    if ! test -f ~/pwiz/modules/$1.pwm ; then
	pwiz_fatal "module $1 not found"
    fi
    shift
    . ~/pwiz/modules/$pwiz_module_current.pwm "$@"
    pwiz_module_current="$pwiz_module_current_save"
}

#@ pwiz_module_load module_name1 module_name2 ...
# Loads needed modules (only modules required for module init)
function pwiz_module_needs {
    local module
    for module in "$@" ; do
	pwiz_module_load "$module"
    done
}

#@ pwiz_module_load module_name1 module_name2 ...
# Checks for needed modules (modules can be loaded later)
# FIXME: implement it
function pwiz_module_uses {
    :
}

# -----------------------

# FIXME: phases for subpackage testing.

#@@ phase skeleton
#@ NOTE: Recommendation for custom phases: Use lowecase. Take these ones as "constants".
#@ If your action surely does not need any action before it in the
#@ same range, you can use listed phases, otherwise create own phase.
#@ Each phase has counterpair {phase}_LAST for simple and portable adding to the end of actions.
#@ WARNING: For listed major phases, avoid if possible: pwiz_phase_add before PHASE
#@ WARNING: For listed major phases, avoid if possible: pwiz_phase_add after PHASE_LAST
#@ basic phase descriptions:
#@ BEGIN
#@  > special general actions
#@ START
#@  > general actions only, $pwiz_project_* attributes are not defined
#@ PROJECT
#@  > project and version selection process, here you can set $pwiz_project_*
# FIXME: rename it?:
#@ SETUP
#@  > set up pwiz for work with known project, access where appropriate ($PWIZ_TMPSDIR)
#@ SOURCE
#@  > get sources, set extended project attributes, $pwiz_project_* are set, access to $PWIZ_SOURCESDIR
#@ PREPARE
#@  > prepare source code (unpack, patch), access to $PWIZ_SRCDIR
#@    subphases: PREPARE_CLEAN PREPARE_PREUNPACK PREPARE_UNPACK PREPARE_POSTUNPACK PREPARE_CHECK PREPARE_PATCH PREPARE_RECHECK
#@ BUILD
#@  > build project (configure, compile), access to $PWIZ_BUILDDIR
#@    subphases: BUILD_SETENV BUILD_CONF BUILD_POSTCONFHACK BUILD_PRECOMPILE BUILD_COMPILE BUILD_POSTCOMPILE
#@ PREINSTALL
#@  > special actions before installation to install root, keep empty if possible
#@    WARNING: use premerge for standard pre-installation processes
#@ INSTALL
#@  > install project, access to $PWIZ_INSTALLROOT
#@    subphases: INSTALL_PREPARE INSTALL_PREACTION INSTALL_ACTION INSTALL_POSTACTION INSTALL_CHECK INSTALL_POSTCHECK
#@ CHECKINSTALL
#@  > Check all installed things. Read access.
#@ PREMERGE
#@  > actions before install, access to live system only special actions
#@ MERGE
#@  > merge project for live system, access to live system
#@ CLEAN
#@  > clean project buld environment, access to all temporary dirs
#@ POSTINSTALL
#@  > post installation actions, access to live system
#@ RUNTEST
#@  > tests for instaled package, access to live system
#@ PREUNINSTALL
#@  > special actions before package uninstallation
#@ UNMERGE
#@  > perform uninstallation, access to live system
#@ POSTUNINSTALL
#@  > special actions after package uninstallation, access to live system
#@ RESULTS
#@  > very last actions, access to $PWIZ_RESULTDIR
#@ FINISH
#@  > very last actions, access nowhere
#@ END
function init_phase_skeleton {
    local phase prev_phase
    prev_phase=BEGIN
    for phase in START PROJECT SETUP SOURCE\
	PREPARE PREPARE_CLEAN PREPARE_PREUNPACK PREPARE_UNPACK PREPARE_POSTUNPACK PREPARE_CHECK PREPARE_PATCH\
	BUILD BUILD_SETENV BUILD_CONF BUILD_POSTCONFHACK BUILD_PRECOMPILE BUILD_COMPILE BUILD_POSTCOMPILE\
	PREINSTALL\
	INSTALL INSTALL_PREPARE INSTALL_PREACTION INSTALL_ACTION INSTALL_POSTACTION INSTALL_CHECK INSTALL_POSTCHECK\
	CHECKINSTALL PREMERGE MERGE CLEAN POSTINSTALL RUNTEST PREUNINSTALL UNINSTALL POSTUNINSTALL RESULTS FINISH ; do
	pwiz_phase_new $phase after $prev_phase
	pwiz_phase_new ${phase}_LAST after $phase
	prev_phase=${phase}_LAST
    done
}


#  FIXME: In conf file.
engine_cache=file
engine_question=dumb
# FIXME: Default should be none
engine_pkgdb=rpm

if $OPTARG_LIST_MODULES ; then
    PWIZ_VERBOSE_COUNT=0
else
    vecho -e "\nInitializing PWIZ..."
    PWIZ_VERBOSE_COUNT=1
fi

if test $OPTCNT_VERBOSE -ge $PWIZ_VERBOSE_COUNT ; then
	eecho
	eecho "Engines..."
fi
for pwiz_file in cache question pkgdb ; do
    if test $OPTCNT_VERBOSE -ge $((PWIZ_VERBOSE_COUNT+2)) ; then
	eecho
    fi
    if test $OPTCNT_VERBOSE -ge $PWIZ_VERBOSE_COUNT ; then
	if $OPTARG_LIST_MODULES ; then
	    eecho -n "Engine"
	else
	    eecho -n "Loading engine"
	fi
	eval "eecho -n \" $pwiz_file: \$engine_$pwiz_file\""
	if test $OPTCNT_VERBOSE -ge $((PWIZ_VERBOSE_COUNT+1)) ; then
	    eval "eecho -n \" (\$(pwiz_engine_desc $pwiz_file \${engine_$pwiz_file:-\$engine_$pwiz_file}))\""
	fi
	eecho "..."
    fi
    if test $OPTCNT_VERBOSE -ge $((PWIZ_VERBOSE_COUNT+2)) ; then
	eval "pwiz_engine_longdesc $pwiz_file \${engine_$pwiz_file:-\$engine_$pwiz_file}"
    fi
    if ! $OPTARG_LIST_MODULES ; then
	eval "pwiz_engine_load $pwiz_file \${engine_$pwiz_file:-\$engine_$pwiz_file}"
    fi
done

if test $OPTCNT_VERBOSE -ge $PWIZ_VERBOSE_COUNT ; then
    eecho
    eecho "Modules..."
fi
if $OPTARG_LIST_MODULES ; then
    for pwiz_file in $(pwiz_modules_list) ; do
	if test $OPTCNT_VERBOSE -ge 2 ; then
	    eecho
	fi
	eecho -n "Module: $pwiz_file"
	if test $OPTCNT_VERBOSE -ge 1 ; then
	    eecho -n " ($(pwiz_module_desc $pwiz_file))"
	fi
	eecho "..."
	if test $OPTCNT_VERBOSE -ge 2 ; then
	    pwiz_module_longdesc $pwiz_file
	fi
    done
    eecho
    exit
fi

# Maybe FIXME:
unset debug_option engine_cache engine_question engine_pkgdb pwiz_file PWIZ_VERBOSE_COUNT

init_phase_skeleton

pwiz_modules_load

# FIXME: feature list and all
# FIXME: Report unknown features.
#@ Debug messages (cannot appear in module init phase).
IFS="${IFS}:,"
pwiz_debug_list=false
for pwiz_debug_feature in ${pwiz_debug_features[@]} ; do
    pwiz_feature_active=false
    for pwiz_debug_option in $OPTVAL_DEBUG ; do
	if test "$pwiz_debug_option" = list ; then
	    pwiz_debug_list=true
	else
	    if test "$pwiz_debug_option" = "$pwiz_debug_feature" ; then
		pwiz_feature_active=true
	    fi
	fi
    done
    if $pwiz_feature_active ; then
	eval pwiz_debug_$pwiz_debug_feature\=true
	eval "function decho_$pwiz_debug_feature {
    echo >&2 \"\$@\"
}"
    else
	eval pwiz_debug_$pwiz_debug_feature\=false
	eval "function decho_$pwiz_debug_feature {
    :
}"
    fi
done
IFS=${IFS%??}


if $pwiz_debug_list ; then
    PWIZ_VERBOSE_COUNT=0
else
    PWIZ_VERBOSE_COUNT=1
fi

if test $OPTCNT_VERBOSE -ge $PWIZ_VERBOSE_COUNT ; then
	eecho
	eecho "Debug features..."
fi
pwiz_debug_on="on"
pwiz_debug_off="off"
for pwiz_debug_feature in ${pwiz_debug_features[@]} ; do
    if test $OPTCNT_VERBOSE -ge $((PWIZ_VERBOSE_COUNT+2)) ; then
	eecho
    fi
    if test $OPTCNT_VERBOSE -ge $PWIZ_VERBOSE_COUNT ; then
	eecho -n ""
	eval "eecho -n \"Debug feature $pwiz_debug_feature \""
	eval "if \$pwiz_debug_$pwiz_debug_feature ; then eecho -n \"$pwiz_debug_on\" ; else eecho -n \"$pwiz_debug_off\" ; fi"
	if test $OPTCNT_VERBOSE -ge $((PWIZ_VERBOSE_COUNT+1)) ; then
	    eval "eecho -n \" (\$pwiz_debug_desc_$pwiz_debug_feature)\""
	fi
	eecho ""
    fi
    if test $OPTCNT_VERBOSE -ge $((PWIZ_VERBOSE_COUNT+2)) ; then
	eval "eecho \" \$pwiz_debug_longdesc_$pwiz_debug_feature\""
    fi
done
vecho
if $pwiz_debug_list ; then
    exit
fi
unset pwiz_debug_option pwiz_debug_feature pwiz_feature_active PWIZ_VERBOSE_COUNT pwiz_debug_list pwiz_debug_on pwiz_debug_off



pwiz_projectdirs_init

while pwiz_step run ; do
    :
done

# FIXME:
set >$PWIZ_TMPDIR/pwiz.set

pwiz_exit
