#! /bin/bash

case $1 in
    desc )
	echo "file list simplification"
	return
	;;
    longdesc )
	echo "This module simplifies the file list of package. It makes it better human readable."
	return
	;;
    init )
	pwiz_module_needs filelist
	pwiz_phase_new_callme filelist_simplify before filelist_finish
	;;
    filelist_simplify )
set -x
	unset filelist_simplify_files
	unset filelist_simplify_types
	unset filelist_simplify_taglines

# Read file list to memory.
	filelist_simplify_count=0
	exec 3<$filelist_file
	while read -u3 filelist_simplify_line ; do
	    filelist_read_item "$filelist_simplify_line"
	    # Create a list of object.
	    filelist_simplify_files[filelist_simplify_count]="$filelist_tag_name"
	    filelist_simplify_types[filelist_simplify_count]="$filelist_tag_type"
	    filelist_simplify_taglines[filelist_simplify_count++]="$filelist_tagline"
	done
	exec 3<&-

# FIXME: simplify dir dir/file too: %dir /opt/gnome/share/pixmaps/splash x /opt/gnome/share/pixmaps/splash/gnome-splash.png

# FIXME:  Simplify on predefined pattern
	# Make a simplification.
	for (( filelist_simplify_count=0 ; filelist_simplify_count < ${#filelist_simplify_files[@]} ; filelist_simplify_count++ )) ; do
	    filelist_simplify_file="${filelist_simplify_files[filelist_simplify_count]}"
	    filelist_simplify_type="${filelist_simplify_types[filelist_simplify_count]}"
	    filelist_simplify_tagline="${filelist_simplify_taglines[filelist_simplify_count]}"
# FIXME: Here we use non-standard access to fields.
	    filelist_simplify_tagext="${filelist_simplify_tagline#*@}"
	    if test "$filelist_simplify_tagext" = "$filelist_simplify_tagline" ; then
		filelist_simplify_tagext=
	    fi

	    # Is object owned?
	    # FIXME: maybe add attribute owned/unowned
	    if test "$filelist_simplify_type" = odir -o  "$filelist_simplify_type" = ofile ; then
		continue
	    fi

	    # Is object covered by previous simplification?
	    if test -z "$filelist_simplify_file" ; then
		continue
	    fi
	    filelist_simplify_valid_pattern=

	    # For file /p/a/t/h/file we will try /p/a/t/h/* /p/a/t/* /p/a/* /p/* /*.
	    # For directory /p/a/t/h we will try /p/a/t/h/* /p/a/t/* etc.

	    # Special case for directory with its contents:
	    # If directory is in list, it cannot be in unowned list.
	    # It means, if pattern fits and directory is oned, don't use "*".
	    if test "$filelist_simplify_type" = dir ; then
# FIXME: move path part cutting down to while and don't add components
		filelist_simplify_path="$filelist_simplify_file/dir"
	    else
		filelist_simplify_path="$filelist_simplify_file"
	    fi

# FIXME: If path is not absolute, dead loop occurs
	    while test "$filelist_simplify_path" != "" ; do
		# Cut rightmost part of path.
		filelist_simplify_path="${filelist_simplify_path%/*}"

# FIXME: There can be more patterns in future.
		for filelist_simplify_pattern in "$filelist_simplify_path/*" ; do
		    filelist_simplify_usable=true
		    echo "*** simplify pattern: $filelist_simplify_pattern"
		    for (( filelist_simplify_count2=0 ; filelist_simplify_count2 < ${#filelist_simplify_files[@]} ; filelist_simplify_count2++ )) ; do
			filelist_simplify_file2="${filelist_simplify_files[filelist_simplify_count2]}"
			filelist_simplify_type2="${filelist_simplify_types[filelist_simplify_count2]}"
			echo "*** compares with: $filelist_simplify_file2"
			if test "$filelist_simplify_type2" = odir -o  "$filelist_simplify_type2" = ofile ; then
			    echo "*** (unowned)"
			    # If any unowned object match, the simplicifation is invalid.
			    case "$filelist_simplify_file2" in
				$filelist_simplify_pattern )
				    echo "*** $filelist_simplify_file2 breaks this simplification"
				    filelist_simplify_usable=false
				    break
				    ;;
			    esac
			else
			    echo "*** (owned)"
			    # If any owned object with different attributes match, the simplicifation is invalid.
			    case "$filelist_simplify_file2" in
				$filelist_simplify_pattern )
# FIXME: Write filelist_simplify_make_tagext
				    filelist_simplify_tagline2="${filelist_simplify_taglines[filelist_simplify_count2]}"
				    filelist_simplify_tagext2="${filelist_simplify_tagline2#*@}"
				    if test "$filelist_simplify_tagext2" = "$filelist_simplify_tagline2" ; then
					filelist_simplify_tagext2=
				    fi
				    if test "$filelist_simplify_tagext" != "$filelist_simplify_tagext2" ; then
					echo "*** $filelist_simplify_file2 attributes breaks this simplification"
					filelist_simplify_usable=false
					break
				    fi
				    ;;
			    esac
			fi
		    done

		    # Usable pattern found. Let's break a pattern loop.
		    if $filelist_simplify_usable ; then
			break
		    fi
		done


# FIXME: Maybe have only one list with all objects.

# Valid simplification found.
		if $filelist_simplify_usable ; then

		    if test "$filelist_simplify_type" = dir -a "$filelist_simplify_file" = "${filelist_simplify_pattern%??}" ; then
			# If it is directory itself with contents, cut trailing "/*".
			filelist_simplify_valid_pattern="${filelist_simplify_pattern%??}"
			filelist_simplify_valid_glob_pattern="$filelist_simplify_pattern"
		    else
			filelist_simplify_valid_pattern="$filelist_simplify_pattern"
			filelist_simplify_valid_glob_pattern="$filelist_simplify_pattern"
		    fi

		    echo "*** simplification $filelist_simplify_valid_pattern"

		else
		    # This simplification is not usable. Don't try any shorter.
		    break
		fi
# Loop to try to find even better simplification.
	    done

# Pattern searching finished.

# If simplification was found, remove all obsolete items from list.
	    if test -z "$filelist_simplify_valid_pattern" ; then
		echo "*** no valid simplification"
	    else

		# Keep all attributes except type, set type to "glob".
		if test "$filelist_simplify_tagext" = "" ; then
		    filelist_simplify_tagline=glob
		else
		    filelist_simplify_tagline="glob@$filelist_simplify_tagext"
		fi

		# Remove all matches from list.
# FIXME: Note: Matches cannot contain unowned object.
		# Clean current item explicitly (for directory with contents case).
		filelist_simplify_files[filelist_simplify_count]=
		for (( filelist_simplify_count2=0 ; filelist_simplify_count2 < ${#filelist_simplify_files[@]} ; filelist_simplify_count2++ )) ; do
		    case "${filelist_simplify_files[filelist_simplify_count2]}" in
			# Check against "/*" ending version of string, not against glob string.
			# (Directory itself contents is by glob itself.)
			$filelist_simplify_valid_glob_pattern )
			    echo "*** removing globbed ${filelist_simplify_files[filelist_simplify_count2]}"
			    filelist_simplify_files[filelist_simplify_count2]=
			    ;;
		    esac
		done

		# Replace object with glob list.
		filelist_simplify_files[filelist_simplify_count]="$filelist_simplify_valid_pattern"
		filelist_simplify_taglines[filelist_simplify_count]="$filelist_simplify_tagline"

	    fi
	# Go to next object in list.
	done

# FIXME:
set >$filelist_file_tmp.set
	pwiz_redirect_stdout $filelist_file_tmp
	# Output result
	for (( filelist_simplify_count=0 ; filelist_simplify_count < ${#filelist_simplify_files[@]} ; filelist_simplify_count++ )) ; do
	    if ! test -z "${filelist_simplify_files[filelist_simplify_count]}" ; then
		echo "${filelist_simplify_files[filelist_simplify_count]} ${filelist_simplify_taglines[filelist_simplify_count]}"
	    fi
	done
	unset filelist_simplify_files
	unset filelist_simplify_types
	unset filelist_simplify_taglines
	pwiz_redirect_stdout_close
set +x
# FIXME:
cp -a $filelist_file $filelist_file_tmp.sim1
cp -a $filelist_file_tmp $filelist_file_tmp.sim2
	LC_ALL=C sort <$filelist_file_tmp | uniq >$filelist_file
	return
	;;
    version )
	echo "0.1"
	return
	;;
    * )
	return
	;;
esac
