#! /bin/bash

case $1 in
    desc )
	echo "file list utilities"
	return
	;;
    longdesc )
	echo "This module contains framework for creating and improving file lists."
	return
	;;
    init )
# Phase providing preliminary file list during installation.
	pwiz_phase_new_call filelist_install after INSTALL_CHECK
	pwiz_phase_new_call filelist_raw after CHECKINSTALL
	pwiz_phase_new_call filelist_clean after filelist_raw
	pwiz_phase_new filelist_inspect after filelist_clean
# FIXME: not used???
	pwiz_phase_new filelist_finish after filelist_inspect
# FIXME
#	pwiz_phase_new filelist_split after filelist_fix
# FIXME: do not register twice for subsequent packages
        pwiz_run_wrapper_register installwatch_run_wrapper
	pwiz_debug_feature unowned "unowned files and directories" "This feature lists owner packages of files and directories installed in the same tree."
	;;
    version )
	echo "0.1"
	return
	;;
    * )
	return
	;;
esac

function filelist_install {
    filelist_generate
}

function filelist_raw {
    #@ Raw file list name for list creator process.
    filelist_raw_file=$PWIZ_TMPDIR/filelist_raw.lst
    $filelist_raw_provider_function
}

function filelist_clean {
    #@ File list name for inspect processes.
    filelist_file=$PWIZ_TMPDIR/filelist.lst
    #@ Temporary file name for inspect processes.
    filelist_file_tmp=$PWIZ_TMPDIR/filelist.lst~
    # dual uniq makes sorting faster in many cases
    # FIXME: remove temporaries
    # fixme: sort -i
    uniq <$filelist_raw_file | tee $filelist_raw_file.0 | filelist_raw_clean_1 | tee $filelist_raw_file.1 | LC_ALL=C sort -u | filelist_raw_clean_2 | tee $filelist_raw_file.2 >$filelist_file
}

#@ filelist_raw_add file type (internal)
#@ echo an item for raw filelist
#@ WARNING: to add an item to raw filelist, you need filelist_raw_open, filelist_raw_close
# FIXME: implement no install root
function filelist_raw_clean_1 {
    while filelist_read_item 0 ; do
	case $filelist_tag_name in
# FIXME: not fixed list
	    $PWIZ_SRCDIR/* | $PWIZ_BUILDDIR/* | $PWIZ_SOURCESDIR/* | $PWIZ_TMPDIR/* )
		;;
	    $PWIZ_INSTALLROOT/* )
# FIXME: Does -e work for absolute chrooted danglinks?
		if test -e "$filelist_tag_name" ; then
		    pwiz_canonize "${filelist_tag_name##$PWIZ_INSTALLROOT}"
		    filelist_tag_name="$pwiz_result"
# FIXME: ignores tagext
		    if test $filelist_tag_type = dir ; then
# FIXME: remove redirection
# FIXME: implement and ask more files at once
# FIXME: dump file attributes
			echo "$filelist_tag_name dir"
		    else
			echo "$filelist_tag_name file"
		    fi
		fi
		;;
	    /tmp/* | /dev/null | /dev/tty* | /var/tmp/* )
		;;
	    * )
		echo >&2 "ERROR: FIXME: access violation $filelist_tag_name"
		;;
	esac
    done
}

function filelist_raw_clean_2 {
    local pkg sub owned
    while filelist_read_item 0 ; do
	if test $filelist_tag_type = dir ; then
# FIXME: implement and ask more files at once
	    pwiz_pkgdb_what_owns "$filelist_tag_name"
# FIXME: For non install root installation, we should generate ofile, too (but can be based on mtime).
	    # If directory is owned by any installed package except this one and sub candidates, it is unowned.
	    owned=true
	    decho_unowned -n "$filelist_tag_name owned by"
	    for pkg in "${pwiz_result[@]}" ; do
# FIXME: This is questionable, whether dir owned by our package and other one is OK.
# FIXME: By default, we consider, that it is a mistake of currently installed package.
		decho_unowned -n " $pkg"
		if test "$pkg" != "$pwiz_project_project" ; then
		    owned=false
		    for sub in "${filelist_split_candidates[@]}" ; do
			if test "$pkg" = "$pwiz_project_project-$sub" ; then
			    owned=true
			    break
			fi
		    done
		    if $owned ; then
			break
		    fi
		fi
	    done
# FIXME: Ignores tagext.
	    if $owned ; then
		decho_unowned "... owned"
		echo "$filelist_tag_name dir"
	    else
		decho_unowned "... unowned"
		echo "$filelist_tag_name odir"
	    fi
	else
	    echo "$filelist_tag_name file"
	fi
    done
}

#@ filelist_raw_open
#@ function for filelist_raw_add
#@ filelist_raw_close
#@ function for filelist_raw_add
function filelist_raw_open {
    pwiz_redirect_stdout $filelist_raw_file
}
function filelist_raw_close {
    pwiz_redirect_stdout_close
}

#@ filelist_raw_provider
#@ function for init of modules providing filelist_raw argument and functionality.
#@ filelist_raw_provider should call filelist_raw_add
function filelist_raw_provider {
    filelist_raw_provider_function=${pwiz_module_current}_filelist_raw
}

# FIXME: Maybe filelist_inspect_callback can be more efficient.
# FIXME: But there can be problems with special modules, requiring whole list in time.

#@ filelist_inspect_provider
#@ function for init of modules providing filelist_inspect argument and functionality.
function filelist_inspect_provider {
    pwiz_phase_add_callme filelist_inspect
}

#@ filelist_install_provider
#@ function for filelist inspections during INSTALL phase
function filelist_install_provider {
    pwiz_phase_add_callme filelist_install
}
#@ filelist_generate
#@ generate file list in any moment.
#@ Clean list is generated, but no inspectors are called.
# FIXME: Incremental list generation can save time
function filelist_generate {
    filelist_raw
    filelist_clean
}

#@ filelist_read_open [stream#]
#@ function for filelist_read_item
#@ filelist_read_close [stream#]
#@ function for filelist_read_item
# ba default uses stream 3
function filelist_read_open {
    local stream=${1:-3}
    eval exec $stream\<$filelist_file
}
function filelist_read_close {
    local stream=${1:-3}
    eval exec $stream\<\&-
}

# FIXME: can be alias?
# FIXME: tag oriented?
#@ filelist_read_item [stream#]
#@ Input: filelist line
#@ Returns:
#@ filelist_tag_type
#@ filelist_tagline line containing all characters defining tags and type (for special purposes only)
#@ $filelist_tag_{key}
#@ Currently known keys: cat (filelist category - doc...), attr (attributes), sub (subpackage)
# FIXME: include read command here
# NOTE: Works with stream 3
function filelist_read_item {
    local stream=${1:-3}
    local var
    if read -u$stream filelist_line ; then
	for var in ${!filelist_tag_*} ; do
	    unset $var
	done
	filelist_tagline="${filelist_line##* }"
	filelist_tag_name="${filelist_line% *}"
	filelist_tag_type="${filelist_tagline%%@*}"
	filelist_tag_attr=
	filelist_tag_sub=
	local IFS="${IFS}@"
	local tag val
	for tag in ${filelist_tagline#*@} ; do
	    val="${tag#*=}"
	    eval 'filelist_tag_'${tag%%=*}'="$val"'
	done
    else
	return 1
    fi
}

# FIXME implement function filelist_write_item

#@ filelist_split_candidate sub ...
#@ Defines candidate for splitting package to subpackages.
# NOTE: This is required, because in time of inspection, we don't know, whether such subpackage will be created.
# FIXME: split name can contain -, but shell variable not
function filelist_split_candidate {
    local sub
    for sub in "$@" ; do
	pwiz_array_add filelist_split_candidates "$sub"
    done
    eval unset filelist_split_candidate_prerequires_${sub}
    eval unset filelist_split_candidate_requires_${sub}
}

# filelist_split_candidate_prerequires subpackage what_requires
function filelist_split_candidate_prerequires {
    eval 'pwiz_array_add filelist_split_candidate_prerequires__'$1' "$2"'
}

# filelist_split_candidate_requires subpackage what_requires
function filelist_split_candidate_requires {
    eval 'pwiz_array_add filelist_split_candidate_requires__'$1' "$2"'
}

# FIXME: There can be splitting package -> package + othername
# FIXME: Splitting package and splitting %post.
