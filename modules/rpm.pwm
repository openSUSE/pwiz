#! /bin/bash

case $1 in
    desc )
	echo "RPM support for PWIZ"
	return
	;;
    longdesc )
	echo "This module is adds support for RPM and overwrites some default definitions."
	return
	;;
    init )
	pwiz_module_needs package version unpack
	pwiz_module_uses filelist unpack
# FIXME: after package or after SOURCE?
	pwiz_phase_new_call rpm_setup after package
# FIXME: not used:
	pwiz_phase_new rpm_header after rpm_setup
# FIXME: move from init:
	pwiz_phase_add_rem PREPARE  ""
	pwiz_phase_add_rem PREPARE  "%prep"
	pwiz_phase_add     PREPARE  'rpm_section=prep ; rm -f $PWIZ_TMPDIR/rpm_{vars,pwd}'
	pwiz_phase_add_rem BUILD    ""
	pwiz_phase_add_rem BUILD    "%build"
	pwiz_phase_add     BUILD    'rpm_section=build ; rm -f $PWIZ_TMPDIR/rpm_{vars,pwd}'
	pwiz_phase_add_rem INSTALL  ""
	pwiz_phase_add_rem INSTALL  "%install"
	pwiz_phase_add     INSTALL  'rpm_section=install ; rm -f $PWIZ_TMPDIR/rpm_{vars,pwd}'
	pwiz_phase_add_run INSTALL  'rm -rf $RPM_BUILD_ROOT'
	pwiz_phase_add_rem CLEAN    ""
	pwiz_phase_add     CLEAN    'rpm_section=clean ; rm -f $PWIZ_TMPDIR/rpm_{vars,pwd}'
# FIXME: non build-rooted packages
	pwiz_phase_add_rem CLEAN    "%clean"
	pwiz_phase_add_run CLEAN    'rm -rf $RPM_BUILD_ROOT'
	pwiz_phase_add_rem POSTINSTALL ""
	pwiz_phase_add_rem POSTINSTALL "%post"
# FIXME
	pwiz_phase_add     POSTINSTALL 'rpm_section=post ; rm -f $PWIZ_TMPDIR/rpm_{vars,pwd} ; cd /'
	pwiz_phase_new_call rpm_files_finish after FINISH
	pwiz_phase_new_call rpm_files_list after rpm_files_finish
# FIXME: remove this
#	pwiz_run_wrapper_register rpm_spec_run_wrapper
	rpm_section=preamble
	rpm_files_args=
	;;
    version )
	echo "0.1"
	return
	;;
    * )
	return
	;;
esac

function rpm_setup {
# FIXME: This phase should be at the end of process, not beginning
	# FIXME: Extract these attributes from spec file, if it exists, either old one or bundled.
    rpm_add_preamble Name         $pwiz_project_project
    rpm_add_preamble Version      $pwiz_project_version
    pwiz_ask_string "Enter RPM group for main package." \
	"RPM requires assigning group attribute for any package created. You should select one of the list." \
	q=rpm_group__ default=Other p=0
    rpm_group__="$pwiz_answer"
    rpm_add_preamble Group        "$rpm_group__"
    pwiz_ask_string "Enter RPM license for main package." \
	"RPM requires assigning license attribute for any package created. You should select one of the list." \
	q=rpm_license default=Unknown p=0
    rpm_license="$pwiz_answer"
    rpm_add_preamble License      "$rpm_license"
    rpm_add_preamble Release      0
    rpm_add_preamble Source       $package_uri
    rpm_add_preamble BuildRoot    %{_tmppath}/%{name}-%{version}-build
    pwiz_ask_string "Enter RPM summary for main package." \
	"RPM requires assigning one-line summary attribute for any package created. You should now write any." \
	q=rpm_summary__
    rpm_summary__="$pwiz_answer"
    rpm_add_preamble Summary      "$rpm_summary__"
    pwiz_ask_string "Enter RPM description for main package." \
	"RPM requires assigning multiple line description attribute for any package created. You should now write any." \
	q=rpm_description__ default= p=0
    rpm_description__="$pwiz_answer"
    rpm_add_description           "$rpm_description__"
}

function rpm_files_finish {
    pwiz_phase_add_rem rpm_files_finish ""
    pwiz_phase_add_rem rpm_files_finish "%files$rpm_files_args"
}

function rpm_files_list {
# FIXME: move to globals or other section, do not create final list, but replace dir -> systemdir
    filelist_read_open
    exec 4>$PWIZ_TMPDIR/rpm_sub_tmp
    while filelist_read_item ; do
	if test "$filelist_tag_sub" = "" ; then
	    rpm_files_create
	else
	    echo "$filelist_tag_sub" >&4
	fi
    done
    filelist_read_close
    exec 4>&-
# FIXME: This should be in general part.
    uniq <$PWIZ_TMPDIR/rpm_sub_tmp | LC_ALL=C sort | uniq >$PWIZ_TMPDIR/rpm_sub
    for rpm_supbackage in $(<$PWIZ_TMPDIR/rpm_sub) ; do
	pwiz_phase_add_rem rpm_files_list ""
# FIXME: support rpm_files_args
	pwiz_phase_add_rem rpm_files_list "%files $rpm_supbackage"
	filelist_read_open
	while filelist_read_item ; do
	    if test "$filelist_tag_sub" = "$rpm_supbackage" ; then
		rpm_files_create
	    fi
	done
	filelist_read_close
    done
}

# FIXME: zip archives etc.
# FIXME: Ask for directory and not try it.
function unpack_prepare {
#    mkdir $PWIZ_TMPDIR/rpm_unpack
#    cd $PWIZ_TMPDIR/rpm_unpack
#    $unpack_seq "$PWIZ_SOURCESDIR/$pwiz_project_project/${package_uri##*/}"
#    pwiz_exec unpack search_dirname
#    cd -
#    rm -rf $PWIZ_TMPDIR/rpm_unpack
# FIXME:
    pwiz_phase_add_run unpack '%setup'
# FIXME: probably obsolete
#    pwiz_phase_add     unpack 'rpm_section=prep_after_setup'
}

# FIXME: This wrapper is obsolete (maybe will be used for %post in future).
function rpm_run_wrapper {
# FIXME: Not complete
    expanded="$(rpm -E "%define name $pwiz_project_project
%define version $pwiz_project_version
%define setup $unpack_seq $PWIZ_SOURCESDIR/${package_uri##*/} ; cd %{name}-%{version}
$*")"
    echo "*** RPM expanded: $expanded"
    eval pwiz_run_wrap "$expanded"
}

# redefinition of run wrapper core
function pwiz_run_core {
# FIXME: to pwiz_run_prepare
# FIXME: Flexible %setup
# FIXME: %post etc.
    case $rpm_section in
	prep )
	    rpm_create_spec -bp prep false "$@"
	    ;;
# FIXME: probably obsolete
#	prep_after_setup )
#	    rpm_create_spec -bp prep false "$@"
#	    ;;
	build )
	    rpm_create_spec "-bc --short-circuit" build true "$@"
	    ;;
# NOTE: rpmbuild has no support for calling clean
# FIXME: This is not OK for %post. It has different environment.
	install | clean | post )
	    rpm_create_spec "-bi --short-circuit" install true "$@"
	    ;;
	* )
	    pwiz_fatal "Unimplemented RPM section"
	    ;;
    esac
    cd $PWIZ_SOURCESDIR
    rpmbuild $rpm_build_arg $PWIZ_TMPDIR/rpm_tmp.spec
    if test -f $PWIZ_TMPDIR/pwd ; then
	cd "$(<$PWIZ_TMPDIR/pwd)"
    fi
    pwiz_set_rc $pwiz_run_rc
}

#@ rpm_create_spec rpm_build_arg section add_setup "$@"
function rpm_create_spec {
    rpm_build_arg="$1"
    echo >$PWIZ_TMPDIR/rpm_tmp.spec \
"Name:         $pwiz_project_project
Version:      $pwiz_project_version
Group:        DUMMY
License:      DUMMY
Release:      0
Source:       $package_uri
BuildRoot:    %{_tmppath}/%{name}-%{version}-build
Summary:      DUMMY
%define __check_files false

%description
DUMMY

%prep"
    if $3 ; then
	echo >>$PWIZ_TMPDIR/rpm_tmp.spec "%setup"
    fi
    if test $2 != prep ; then
	echo >>$PWIZ_TMPDIR/rpm_tmp.spec -e "\n%$2"
    fi
    shift 3
    echo >>$PWIZ_TMPDIR/rpm_tmp.spec \
$'pwiz_set_options="$(set -o | while read ; do if test "${REPLY##*\t}" = on ; then echo "set -o ${REPLY%%\t*}" ; else echo "set +o ${REPLY%%\t*}" ; fi ; done)"'"
set +o posix
if test -f $PWIZ_TMPDIR/rpm_env ; then
    $PWIZ_TMPDIR/rpm_env 2>/dev/null || true
else
    eval \"\$pwiz_set_options\"
fi
$*
export >$PWIZ_TMPDIR/rpm_env
set >>$PWIZ_TMPDIR/rpm_env
"$'set -o | while read ; do if test "${REPLY##*\t}" = on ; then echo "set -o ${REPLY%%\t*}" ; else echo "set +o ${REPLY%%\t*}" ; fi ; done'" >>$PWIZ_TMPDIR/rpm_env
"$'shopt | while read ; do if test "${REPLY##*\t}" = on ; then echo "shopt -s ${REPLY%%\t*}" ; else echo "shopt -u ${REPLY%%\t*}" ; fi ; done'" >>$PWIZ_TMPDIR/rpm_env
echo \"cd \$PWD\" >>$PWIZ_TMPDIR/rpm_env
echo \"\$PWD\" >$PWIZ_TMPDIR/pwd"
}
# FIXME ^ save set unparset to separate file, and parse if required. Use set +x for parsing.

function pwiz_projectdirs_init_callback {
    PWIZ_SOURCESDIR=/usr/src/packages/SOURCES
    PWIZ_SRCDIR=/usr/src/packages/BUILD
    PWIZ_BUILDDIR=/usr/src/packages/BUILD
    PWIZ_INSTALLROOT=/var/tmp/$pwiz_project_project-$pwiz_project_version-build
}

#@ rpm_subst "string"
#@ substitute %{name}, %{version}
#@ FIXME: implement and substitute %{_name}
#@ BIG FIXME: crashes for packages with "name" and "version" in package name
#@ Returns: $pwiz_result
#@ FIXME: should be part of pwiz_add_run
function rpm_subst_names {
    pwiz_result="$1"
    pwiz_result=${pwiz_result//$pwiz_project_project/%\{name\}}
    pwiz_result=${pwiz_result//$pwiz_project_version/%\{version\}}
}

#@ rpm_files_create (no args) (internal)
function rpm_files_create {
    local item_prefix
    if test "$filelist_tag_cat" = doc ; then
	item_prefix="%doc "
    else
	item_prefix=""
    fi
    case $filelist_tag_type in
	file )
	    pwiz_phase_add_rem rpm_files_list "$item_prefix$filelist_tag_name"
	    ;;
	dir )
	    pwiz_phase_add_rem rpm_files_list "$item_prefix%dir $filelist_tag_name"
	    ;;
	odir | ofile )
	    ;;
	glob )
	    pwiz_phase_add_rem rpm_files_list "$item_prefix$filelist_tag_name"
	    ;;
	* )
	    pwiz_fatal "unknown item attribute $filelist_tag_type"
	    ;;
    esac
}

# rpm_add_subpackage subpackage
function rpm_subpackage_add {
    rpm_subpackage_list="$rpm_subpackage_list $1"
    eval rpm_description__$1\=FIXME
# FIXME:
    pwiz_ask_string "Enter RPM group for subpackage $1." \
	"PWIZ decided to split binary RPM. It requires assigning group attribute for subpackage $1. You should select one of the list." \
	q=rpm_group__$1 default="$rpm_group__" p=20
    rpm_add_preamble Group        "$pwiz_answer" $1
    pwiz_ask_string "Enter RPM summary for subpackage $1." \
	"PWIZ decided to split binary RPM. It requires assigning one-line summary for subpackage $1. You should now write any." \
	q=rpm_summary__$1 default="$rpm_summary__" p=20
    rpm_add_preamble Summary      "$pwiz_answer" $1
    pwiz_ask_string "Enter RPM description for subpackage $1." \
	"PWIZ decided to split binary RPM. It requires assigning multiple line description attribute for any package created. You should now write any." \
	q=rpm_description__ default="$rpm_description__" p=0
    rpm_add_description           "$pwiz_answer" $1
}
declare -a rpm_preamble__
rpm_subpackage_list=

# rpm_add_preamble_line line subpackage
function rpm_add_preamble_line {
    eval 'rpm_preamble__'$2'[${#rpm_preamble__'$2'[@]}]="$1"'
}

# rpm_add_preamble atribute value subpackage
function rpm_add_preamble {
    local pad='              '
    rpm_add_preamble_line "$1: ${pad:${#1}+2}$2" "$3"
}

# rpm_add_description description subpackage
function rpm_add_description {
    eval 'rpm_description__'$2'="$1"'
}

# FIXME: rpm should auto-ask for splitted package args, if none are supported.

# FIXME: Stuff should work, if package name != project name
