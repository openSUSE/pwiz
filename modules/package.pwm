#! /bin/bash

# FIXME: implement package_version in addition to pwiz_project_version

case $1 in
    desc )
	echo "package selection dialog"
	return
	;;
    longdesc )
	echo "This module provides basic dialog for package selection."
	return
	;;
    init )
	pwiz_module_uses unpack version
	pwiz_phase_new package after PROJECT
	pwiz_phase_new_3_guess package_project after PROJECT
	pwiz_phase_new_3_guess package_basename after package_project_set
	pwiz_phase_new_3_guess package_home_page after package_basename_set
	pwiz_phase_new_3_guess package_search_uri after package_home_page_set
	pwiz_guess_add package_search_uri "" 0 "I will enter directly manually download URI."
# FIXME: finish splitting
	pwiz_phase_new_call package_download after package_search_uri_set
	pwiz_debug_feature uri "URI search progress" "This feature turns on verbose displaying of searching of URI."
	;;
    version )
	echo "0.1"
	return
	;;
    * )
	return
	;;
esac

function package_project_prepare {
    unset pwiz_project_project
}

function package_project_set {
# FIXME: implement selection "try another version" and search this version' URL
# FIXME: implement to all error questions: error_default_list
# FIXME: pwiz_project_ -> package_ for names not present in key
    pwiz_ask_string "Project name (name of project for PWIZ)." \
	"Now you should enter canonical project name. The name can be global project name, or any selected, if there is a reason for different name." \
	q=pwiz_project_project valid=setup knowledge=total guesslevel=0 force_overwrite=true
    pwiz_patchlevel_set
}

function package_basename_prepare {
    unset package_basename
}

function package_basename_set {
# FIXME: setting valid=product is not perfect, but in this moment we do not know version.
    pwiz_ask_string "Global project source base file name." \
	"Now you should enter project base file name (i. e. name without prefix, suffix and version). This can be a string or extended pattern (see extglob in bash(1))." \
	q=package_basename default="$pwiz_project_project" valid=product importance=40 c=25
}

function package_home_page_prepare {
    local defaults credit
    unset package_home_page
    # If there is any previous answer, default to no, otherwise yes.
    # Look at validity ranges: For first it is global, for second it
    # is package specific (there can be no home page for particular
    # project).
    pwiz_cache_load q=package_home_page valid=project
    # Unset condition and ask user for value.
    unset package_home_page_condition
    if test "$pwiz_guess_best_value" = "" ; then
	defaults="default=true c=10 valid=setup"
    else
	# Add 1: For default run, ask only once.
	let credit=1+pwiz_guess_best_credit
	defaults="default=false c=$credit valid=project"
    fi
    pwiz_ask_yesno "Do automatic Internet lookup for home page now?" \
	"Now you can lookup for home page. It can take some time. If you know exact URI, answer no." \
	q=package_home_page_condition $defaults importance=10 knowledge=none force_overwrite=true
    true
}

function package_home_page_set {
    pwiz_ask_string "Enter package home page." \
	"Package home page is URI, where home WWW (or FTP) page resides." \
	q=package_home_page valid=project default="" string=unknown
}

function package_search_uri_prepare {
    local defaults credit
    unset package_search_uri
    # If there is any previous answer, default to no, otherwise yes.
    # Look at validity ranges: For first it is global, for second it
    # is package specific (there can be no home page for particular
    # project).
    pwiz_cache_load q=package_search_uri valid=project
    # Unset condition and ask user for value.
    unset package_search_uri_condition
    if test "$pwiz_guess_best_value" = "" ; then
	defaults="default=true c=10 valid=setup"
    else
	# Add 1: For default run, ask only once.
	let credit=1+pwiz_guess_best_credit
	defaults="default=false c=$credit valid=project"
    fi
    pwiz_ask_yesno "Do automatic Internet lookup for search URI now?" \
	"Now you can lookup for home page. It can take some time. If you know exact URI, answer no." \
	q=package_search_uri_condition $defaults importance=10 knowledge=none force_overwrite=true
    true


}

function package_search_uri_set {
    pwiz_ask_string "Enter package search URI." \
	"Package search URI is top-level URI, where sources are searched. Can be space separated list. Note that it works for FTP only now." \
	q=package_search_uri valid=project
}

# FIXME: finish splitting
function package_download {
# FIXME: ugly temporary solution:
    if test -d "$PWIZ_CACHEDIR/ftp/${package_search_uri#ftp://}" ; then
	package_default=false
    else
	package_default=true
    fi
#    if pwiz_ask_yesno "Do FTP lookup now?" \
#	"Now you can lookup for FTP. Stored version will be used otherwise." \
#	default=$package_default importance=5 ; then
    ftp_list_recursive $package_search_uri package_collect_uri
    pwiz_guess_add package_version latest 5 "latest conforming policy"
    pwiz_ask_string "Enter required version." \
	"Now you can specify required version. Default is most probably the latest conforming policy. In this case you will be asked for policy to identify latest version. If you are entering version manually, use version string for forced version and \"latest\" for current latest version." \
	q=package_version valid=product
    if test "$package_version" = latest ; then
# FIXME: subproject
# FIXME: more sources with more policies
	version_ask_policy
	version_ask_product_policy
	package_find_latest_version
	# FIXME: What to do, if latest version is not found.
	# Trick: guesslevel is 0. Answer is cached with no credit.
	# If you want to browse web, it has no credibility, if you
	# don't want, you will be asked each time.
	# You will be notified about update.
	# FIXME: Auto-update feature (d not ask before overwriting)
	# means implementing volatile=true
	pwiz_guess_add package_latest_version "$pwiz_result" 100
	pwiz_ask_string "What is the latest version conforming policy?" \
	    "This is only a rhetorical question. PWIZ searched package search URI and is nearly sure, that it is suggested one." \
	    q=package_latest_version valid=product knowledge=none guesslevel=100
	# FIXME: maybe tag delay=whatever
	pwiz_project_version=$package_latest_version
    else
	pwiz_project_version=$package_version
    fi
    pwiz_ask_string "Enter required version URI." \
	"Now you can specify URI of required version. Default is most probably the latest URI." \
	q=package_uri_${pwiz_project_version//[.-]/_} valid=product
# FIXME: Use default answer variable
    package_uri=$pwiz_answer
    pwiz_projectdirs_init
# FIXME: ugly, use storage engine
# FIXME: guess type by contents, not URI. Report conflicts.
    if test -f "$PWIZ_CACHEDIR/${package_uri##*/}" ; then
	if pwiz_ask_yesno "Download file now?" \
	    "Now you can dowload file." \
	    default=false c=1 importance=10 ; then
	    ftp_get "$package_uri"
	fi
    else
	if pwiz_ask_yesno "Download file now?" \
	    "Now you can dowload file." \
	    default=true c=20 importance=10 ; then
	    ftp_get "$package_uri"
	fi
    fi
}

#@ package_collect_uri URI
# URI: URI information to be collected
# returns: 0: known archive, 1: unknown file
# returns $pwiz_result: stripped package version
#
# Parses URI and collects guesses of versions and package URIs. (internal)
function package_collect_uri {
    local unpack_credit
    decho_uri -n "found $1..."
    if unpack_check_extension "$1" ; then
	pwiz_result="${pwiz_result##*/}"
	# package_basename can be an extglob pattern
	shopt -s extglob
	if test "$pwiz_result" = "${pwiz_result#$package_basename}" ; then
	    decho_uri " not archive of required package"
	    shopt -u extglob
	    return 1
	else
	    pwiz_result="${pwiz_result#$package_basename}"
	    shopt -u extglob
# package-version separators
	    decho_uri -n " is archive of ${pwiz_result##*/}"
	    pwiz_result="${pwiz_result#[-_]}"
	    let unpack_credit=90+unpack_priority
	    pwiz_guess_add package_uri_${pwiz_result//[.-]/_} "$1" $unpack_credit
	    pwiz_guess_add package_version "$pwiz_result" 0 "force $pwiz_result"
	fi
    else
	decho_uri " not archive"
	return 1
    fi
}

#@ package_find_latest_version
# returns: 0: known archive, 1: unknown file
# returns $pwiz_result: stripped package version
#
# Goes through all versions found and find latest conforming policy. (internal)
function package_find_latest_version {
    local version latest_version
    local -a latest_version_array

    for version in ${pwiz_guess_default_package_version[*]} ; do
	if test "$version" = latest ; then
	    continue
	fi
	decho_uri -n "$version..."
	version_parse "$version"
	if version_policy_check pwiz_result ; then
	    if version_compare pwiz_result latest_version_array ; then
		decho_uri " - latest version yet found"
		latest_version="$version"
		latest_version_array=( "${pwiz_result[@]}" )
	    else
		decho_uri " - newer or same version exists"
	    fi
	else
	    decho_uri " - disabled by policy"
	fi
    done
    pwiz_result=$latest_version
}
